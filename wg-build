#!/usr/bin/env perl
use strict;
use warnings;

our $VERSION = '0.1.0';

use Getopt::Long ();
use Pod::Usage;

my $opt_verbose = 0;
Getopt::Long::Configure(qw(gnu_getopt));
Getopt::Long::GetOptions(
    'h|?|help'          => \(my $opt_help),
    'man'               => \(my $opt_man),
    'V|ver|version'     => \(my $opt_ver),

    'v|verbose'         => sub { $opt_verbose++ },
    'q|quiet'           => sub { $opt_verbose-- },

    'mysql=s'           => \(my $opt_mysql),
    'mysqldump=s'       => \(my $opt_mysqldump),

    'c|config-file=s'   => \(my $opt_config),
    'r|webgui-root=s'   => \(my $opt_root),
    's|sql!'            => \(my $opt_sql),
    'u|uploads!'        => \(my $opt_uploads),
) || pod2usage(2);
if ($opt_help) {
    pod2usage(1);
}
elsif ($opt_man) {
    pod2usage(-verbose => 2);
}
elsif ($opt_ver) {
    print "wg-build - version $VERSION\n";
    exit;
}

require Path::Class;

$opt_config ||= $ENV{WEBGUI_CONFIG} || die "WebGUI config file not specified!\n";
$opt_root   ||= $ENV{WEBGUI_ROOT};
my $config_file = Path::Class::File->new($opt_config);
if ($config_file->is_absolute) {
    $opt_root ||= $config_file->parent->parent;
}
unless (-e $opt_root && -e $opt_root->file('lib', 'WebGUI')) {
    die "Can't find WebGUI root!\n";
}

$opt_sql        = defined $opt_sql      ? $opt_sql
                : defined $opt_uploads  ? !$opt_uploads
                                        : 1;
$opt_uploads    = defined $opt_uploads  ? $opt_uploads
                                        : 0;
# Autoflush
local $| = 1;

require Config::JSON;
print "Loading config... " if $opt_verbose >= 1;
my $config = Config::JSON->new($config_file);
print "Done.\n" if $opt_verbose >= 1;

if ($opt_sql) {
    require DBI;
    require version;
    my $db_file = $opt_root->file('docs', 'create.sql');

    my $mysql = `which mysql` || eval {
        require WRE::Config;
        WRE::Config->new->getRoot('/prereqs/bin/mysql');
    } || die "Unable to find mysql!\n";
    chomp $mysql;
    my $mysqldump = `which mysqldump` || eval {
        require WRE::Config;
        WRE::Config->new->getRoot('/prereqs/bin/mysqldump');
    } || die "Unable to find mysqldump!\n";
    chomp $mysqldump;

    print "Finding current version number... " if $opt_verbose >= 1;
    my ($dsn, $db_name, $db_host, $db_port, $db_user, $db_pass) = get_db_info($config);
    my $dbh = DBI->connect($dsn, $db_user, $db_pass);
    my $sth = $dbh->prepare('SELECT webguiVersion FROM webguiVersion');
    $sth->execute;
    my @versions =
        map { $_->[0] }
        sort { $a->[1] <=> $b->[1]}
        map { [$_, version->new($_)] }
        map {@$_} @{$sth->fetchall_arrayref([0])};
    $sth->finish;
    $dbh->disconnect;
    my $version = pop @versions;
    print "$version. Done.\n" if $opt_verbose >= 1;

    print "Creating database dump... " if $opt_verbose >= 1;
    $db_file->openw->close;

    my @skip_data_tables = qw(
        userSession     userSessionScratch
        webguiVersion   userLoginLog
        assetHistory    cache
    );
    system join(' ',
        $mysqldump, "-u$db_user", "-p$db_pass", "-h$db_host",
        "-P$db_port", '--no-data', '--compact', $db_name,
    ) . ">>$db_file";

    system join(' ',
        $mysqldump, "-u$db_user", "-p$db_pass", "-h$db_host",
        "-P$db_port", '--no-create-info', '--compact', $db_name,
        map { "--ignore-table=$db_name.$_" } @skip_data_tables,
    ) . ">>$db_file";

    my $fh = $db_file->open('a');
    $fh->print("INSERT INTO webguiVersion (webguiVersion,versionType,dateApplied) VALUES ('$version','Initial Install',UNIX_TIMESTAMP());\n");
    $fh->close;
    print "Done.\n" if $opt_verbose >= 1;
}

# Clear and recreate uploads
if ($opt_uploads) {
    require File::Copy;
    print "Loading uploads from site... " if $opt_verbose >= 1;
    my $wg_uploads = $opt_root->subdir('www', 'uploads');
    $wg_uploads->mkpath;
    my $site_uploads = Path::Class::Dir->new($config->get('uploadsPath'));
    $wg_uploads->recurse(preorder => 0, callback => sub {
        my $wg_path = shift;
        for ($wg_path->is_dir ? $wg_path->dir_list : $wg_path->parent->dir_list) {
            return if $_ eq '.svn';
            return if $_ eq 'temp';
        }
        my $site_path = $wg_path->relative($wg_uploads)->absolute($site_uploads);
        return
            if -e $site_path;
        if ($site_path->is_dir) {
            $wg_path->rmtree;
        }
        else {
            $wg_path->remove;
        }
    });
    $site_uploads->recurse(callback => sub {
        my $site_path = shift;
        return
            if $site_path->is_dir;
        for ($site_path->parent->dir_list) {
            return if $_ eq '.svn';
            return if $_ eq 'temp';
        }
        my $wg_path = $site_path->relative($site_uploads)->absolute($wg_uploads);
        $wg_path->parent->mkpath;
        File::Copy::copy($site_path->stringify, $wg_path->stringify);
    });
    print "Done\n" if $opt_verbose >= 1;
}

sub get_db_info {
    my $config = shift;
    my $dsn     = $config->get('dsn');
    my $db_user = $config->get('dbuser');
    my $db_pass = $config->get('dbpass');
    my $db_name = (split(/[:;]/, $dsn))[2];
    my $db_host = 'localhost';
    my $db_port = '3306';
    while ($dsn =~ /([^=;:]+)=([^;:]+)/g) {
        if ($1 eq 'host' || $1 eq 'hostname') {
            $db_host = $2;
        }
        elsif ($1 eq 'db' || $1 eq 'database' || $1 eq 'dbname') {
            $db_name = $2;
        }
        elsif ($1 eq 'port') {
            $db_port = $2;
        }
    }
    return ($dsn, $db_name, $db_host, $db_port, $db_user, $db_pass);
}

1;


__END__

=head1 NAME

wg-build - Rebuilds create.sql or uploads directory based on current site

=head1 SYNOPSIS

wg-build [options] [config ...]

Options:
    --help          brief help message
    --man           full documentation

=head1 OPTIONS

=over 8

=item B<--help>

Print a brief help message and exits.

=item B<--man>

Prints the manual page and exits.

=back

=head1 DESCRIPTION


=cut

