#!/usr/bin/env perl
use strict;
use warnings;

our $VERSION = '0.2.0';

use Getopt::Long ();
use Pod::Usage;

my $opt_verbose = 0;
Getopt::Long::Configure(qw(gnu_getopt));
Getopt::Long::GetOptions(
    'h|?|help'      => \(my $opt_help),
    'man'           => \(my $opt_man),
    'V|ver|version' => \(my $opt_ver),

    'dev!'          => \(my $opt_dev),
    'b|build'       => \(my $opt_build),
    't|test'        => \(my $opt_test),

    'f|fast'        => \(my $opt_fast),

    'i|index!'      => \(my $opt_index),
    'up|upgrade!'   => \(my $opt_upgrade),
    'upload!'       => \(my $opt_upload),
    'delcache!'     => \(my $opt_delcache),
    'v|verbose'     => sub { $opt_verbose++ },
    'q|quiet'       => sub { $opt_verbose-- },

    'debug!'        => \(my $opt_debug),
    'starter!'      => \(my $opt_starter),
    'clear!'        => \(my $opt_clear),
    'purge!'        => \(my $opt_purge),
    'cleantags!'    => \(my $opt_cleantags),
) || pod2usage(2);
if ($opt_help) {
    pod2usage(1);
}
elsif ($opt_man) {
    pod2usage(-verbose => 2);
}
elsif ($opt_ver) {
    print "wg_reset - version $VERSION\n";
    exit;
}

if ($opt_build) {
    $opt_dev        = defined $opt_dev          ? $opt_dev          : 0;
    $opt_verbose++;
}
elsif ($opt_test) {
    $opt_dev        = defined $opt_dev          ? $opt_dev          : 0;
    $opt_upgrade    = defined $opt_upgrade      ? $opt_upgrade      : 0;
}

$opt_dev        = defined $opt_dev          ? $opt_dev          : 1;
$opt_upgrade    = defined $opt_upgrade      ? $opt_upgrade      : 1;
$opt_upload     = defined $opt_upload       ? $opt_upload
                : $opt_fast                 ? 0
                                            : 1;
$opt_delcache   = defined $opt_delcache     ? $opt_delcache
                : $opt_fast                 ? 0
                                            : 1;

$opt_starter    = defined $opt_starter      ? $opt_starter
                : $opt_dev                  ? 0
                : $opt_build                ? 1
                                            : undef;
$opt_debug      = defined $opt_debug        ? $opt_debug
                : $opt_dev                  ? 1
                : $opt_build                ? 0
                                            : undef;
$opt_clear      = defined $opt_clear        ? $opt_clear        : $opt_dev;

$opt_purge      = defined $opt_purge        ? $opt_purge        : $opt_upgrade;
$opt_cleantags  = defined $opt_cleantags    ? $opt_cleantags    : $opt_upgrade;

# load needed modules
unshift @INC, '/data/wre/lib';

require WRE::Config;
require Config::JSON;
require DBI;

$| = 1;

my $wg_root = WRE::Config->new->getWebguiRoot;

my $config_file = (shift @ARGV) || $ENV{WEBGUI_CONFIG} || die <<'END_ERROR';
You must set the WEBGUI_CONFIG environment variable or provide a parameter to determine which site to reset
END_ERROR
print "Loading config... " if $opt_verbose >= 1;
my $config = Config::JSON->new($wg_root . '/etc/' . $config_file);
my ($dsn, $db_name, $db_host, $db_port, $db_user, $db_pass) = get_db_info($config);
print "Done.\n" if $opt_verbose >= 1;

# Clear cache
if ($opt_delcache) {
    require Path::Class;
    print "Clearing cache... " if $opt_verbose >= 1;
    if ($config->get('cacheType') eq 'WebGUI::Cache::FileCache') {
        Path::Class::Dir->new($config->get('fileCacheRoot') || '/tmp/WebGUICache')->rmtree;
    }
    else {
        # We'd clear the DB cache here, but the whole database will be cleared in a later step
    }
    print "Done.\n" if $opt_verbose >= 1;
    
}
# Clear and recreate uploads
if ($opt_upload) {
    require Path::Class;
    require File::Copy;
    print "Recreating uploads... " if $opt_verbose >= 1;
    my $base_uploads = Path::Class::Dir->new($wg_root, 'www', 'uploads');
    my $site_uploads = Path::Class::Dir->new($config->get('uploadsPath'));
    $site_uploads->rmtree;
    $base_uploads->recurse(callback => sub {
        my $base_path = shift;
        #print "$base_path\n";
        my $site_path = $base_path->relative($base_uploads)->absolute($site_uploads);
        if ($site_path->is_dir) {
            for ($base_path->dir_list) {
                return
                    if $_ eq '.svn';
            }
            $site_path->mkpath;
        }
        else {
            for ($base_path->parent->dir_list) {
                return
                    if $_ eq '.svn';
            }
            #print $base_path->stringify, ' -> ', $site_path->stringify, "\n";
            File::Copy::copy($base_path->stringify, $site_path->stringify);
        }
    });
    print "Done\n" if $opt_verbose >= 1;
}

# Connect using dsn and clean out old tables
print "Clearing old database information... " if $opt_verbose >= 1;
my $dbh = DBI->connect($dsn, $db_user, $db_pass);
my $sth = $dbh->table_info(undef, undef, '%');
my @tables = map {@$_} @{$sth->fetchall_arrayref([2])};
for my $table (@tables) {
    $dbh->do('DROP TABLE ' . $dbh->quote_identifier($table));
}
$dbh->disconnect;
print "Done.\n" if $opt_verbose >= 1;

# If we aren't upgrading, we're using the current DB version
print "Importing clean database dump... " if $opt_verbose >= 1;
my $db_file = $opt_upgrade ? 'previousVersion.sql' : 'create.sql';
system('mysql', "-h$db_host", "-P$db_port", $db_name, "-u$db_user", "-p$db_pass", "--batch", "--execute=source $wg_root/docs/$db_file");
print "Done.\n" if $opt_verbose >= 1;

# Run the upgrade in a fork
if ($opt_upgrade) {
    print "Running upgrade script... " if $opt_verbose >= 1;
    my $pid = fork;
    unless ($pid) {
        chdir $wg_root . '/sbin';
        @ARGV = qw(--doit --override --skipBackup);
        push @ARGV, '--quiet'
            if $opt_verbose < 2;
        do 'upgrade.pl';
        exit;
    }
    waitpid $pid, 0;
    print "Done.\n" if $opt_verbose >= 1;
}

if (defined $opt_debug || defined $opt_starter) {
    print "Setting WebGUI settings... " if $opt_verbose >= 1;
    $dbh = DBI->connect($dsn, $db_user, $db_pass);
    if ($opt_debug) {
        $dbh->do("REPLACE INTO settings (name, value) VALUES ('showDebug', '1')");
        $dbh->do("REPLACE INTO settings (name, value) VALUES ('sessionTimeout', '31536000')");
    }
    elsif (defined $opt_debug) {
        $dbh->do("REPLACE INTO settings (name, value) VALUES ('showDebug', '0')");
        $dbh->do("REPLACE INTO settings (name, value) VALUES ('sessionTimeout', '7200')");
    }
    if ($opt_starter) {
        $dbh->do("REPLACE INTO settings (name, value) VALUES ('specialState', 'init')");
    }
    elsif (defined $opt_starter) {
        $dbh->do("DELETE FROM settings WHERE name='specialState'");
    }
    print "Done.\n" if $opt_verbose >= 1;
}

my $wg_session;

if ($opt_clear) {
    print "Clearing example assets... " if $opt_verbose >= 1;
    print "\n" if $opt_verbose >= 2;
    $wg_session ||= wg_session($wg_root, $config_file);
    my $home = WebGUI::Asset->getDefault($wg_session);
    my $children = $home->getLineage(['descendants'], {
        statesToInclude => ['published', 'trash', 'clipboard', 'clipboard-limbo', 'trash-limbo'],
        statusToInclude => ['approved', 'pending', 'archive'],
        excludeClasses  => ['WebGUI::Asset::Wobject::Layout'],
        returnObjects   => 1,
        invertTree      => 1,
    });
    for my $child (@$children) {
        print "\tRemoving " . $child->getName . " '" . $child->get('title') . "'.\n" if $opt_verbose >= 2;
        $child->purge;
    }
    print "Done.\n" if $opt_verbose >= 1;
}

if ($opt_purge) {
    print "Purging old Asset revisions... " if $opt_verbose >= 1;
    print "\n" if $opt_verbose >= 2;
    $wg_session ||= wg_session($wg_root, $config_file);
    require WebGUI::Asset;
    my $sth = $dbh->prepare(<<END_SQL);
    SELECT assetData.assetId, asset.className, assetData.revisionDate
    FROM asset
        LEFT JOIN assetData on asset.assetId=assetData.assetId
    ORDER BY assetData.revisionDate ASC
END_SQL
    $sth->execute;
    while (my ($id, $class, $version) = $sth->fetchrow_array) {
        if (WebGUI::Asset->getCurrentRevisionDate($wg_session, $id) == $version) {
            next;
        }
        my $asset = WebGUI::Asset->new($wg_session, $id, $class, $version)
            || next;
        if ($asset->getRevisionCount("approved") > 1) {
            print "\tPurging $class $version '" . $asset->get('title') . "'\n" if $opt_verbose >= 2;
            $asset->purgeRevision;
        }
    }
    print "Done.\n" if $opt_verbose >= 1;
}

if ($opt_cleantags) {
    print "Cleaning out versions Tags... " if $opt_verbose >= 1;
    my $tag_id = 'pbversion0000000000001';
    my $sth = $dbh->prepare("UPDATE assetData SET tagId = ?");
    $sth->execute($tag_id);
    #$sth = $dbh->prepare("DELETE FROM assetVersionTag WHERE tagId <> ?");
    #$sth->execute($tag_id);
    $sth = $dbh->prepare("DELETE FROM assetVersionTag");
    $sth->execute();
    $sth = $dbh->prepare("INSERT INTO assetVersionTag VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?)");
    $sth->execute($tag_id, 'Initial Install', 1, time(), '3', time(), '3', 0, '', '3', '', undef, undef);
    #$sth = $dbh->prepare("UPDATE assetVersionTag SET name = 'Initial Install', creationDate = ?, commitDate = ? WHERE tagId = ?");
    #$sth->execute(time(), time(), $tag_id);
    print "Done.\n" if $opt_verbose >= 1;
}

$wg_session->close
    if $wg_session;

$dbh->disconnect;

if ($opt_index) {
    print "Rebuilding lineage... " if $opt_verbose >= 1;
    my $pid = fork;
    unless ($pid) {
        if ($opt_verbose < 2) {
            open STDIN,  '<', File::Spec->devnull;
            open STDOUT, '>', File::Spec->devnull;
            open STDERR, '>', File::Spec->devnull;
        }
        print "\n\n";
        chdir $wg_root . '/sbin';
        @ARGV = ('--configFile=' . $config_file);
        do './rebuildLineage.pl';
        exit;
    }
    waitpid $pid, 0;
    print "Done.\n" if $opt_verbose >= 1;

    print "Rebuilding search index... " if $opt_verbose >= 1;
    $pid = fork;
    unless ($pid) {
        if ($opt_verbose < 2) {
            open STDIN,  '<', File::Spec->devnull;
            open STDOUT, '>', File::Spec->devnull;
            open STDERR, '>', File::Spec->devnull;
        }
        print "\n\n";
        chdir $wg_root . '/sbin';
        @ARGV = ('--configFile=' . $config_file, '--indexsite');
        do './search.pl';
        exit;
    }
    waitpid $pid, 0;
    print "Done.\n" if $opt_verbose >= 1;
}

sub get_db_info {
    my $config = shift;
    my $dsn     = $config->get('dsn');
    my $db_user = $config->get('dbuser');
    my $db_pass = $config->get('dbpass');
    my $db_name = (split(/[:;]/, $dsn))[2];
    my $db_host = 'localhost';
    my $db_port = '3306';
    while ($dsn =~ /([^=;:]+)=([^;:]+)/g) {
        if ($1 eq 'host' || $1 eq 'hostname') {
            $db_host = $2;
        }
        elsif ($1 eq 'db' || $1 eq 'database' || $1 eq 'dbname') {
            $db_name = $2;
        }
        elsif ($1 eq 'port') {
            $db_port = $2;
        }
    }
    return ($dsn, $db_name, $db_host, $db_port, $db_user, $db_pass);
}

sub wg_session {
    my $wg_root = shift;
    my $wg_config = shift;
    unshift @INC, $wg_root . '/lib';
    require WebGUI::Session;
    require WebGUI::Asset;
    my $wg_session = WebGUI::Session->open($wg_root, $config_file);
    $wg_session->user({userId => 3});
    return $wg_session;
}

__END__

=head1 NAME

wg_reset - Resets a WebGUI site to the default

=head1 SYNOPSIS

wg_reset [options] [config ...]

Options:
    --help          brief help message
    --man           full documentation

=head1 OPTIONS

=over 8

=item B<--help>

Print a brief help message and exits.

=item B<--man>

Prints the manual page and exits.

=back

=head1 DESCRIPTION

B<wg_reset> will recreate a WebGUI site from the startup database script. This
includes running upgrade scripts as needed and recreating the uploads directory.
There are also options for setting various options useful for development and
creating a new database import script.

=cut

