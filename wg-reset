#!/usr/bin/env perl
use strict;
use warnings;

our $VERSION = '0.1.1';

use Getopt::Long ();
use Pod::Usage;

my $opt_verbose = 1;
Getopt::Long::Configure(qw(gnu_getopt));
Getopt::Long::GetOptions(
    'h|?|help'      => \(my $opt_help),
    'man'           => \(my $opt_man),
    'V|ver|version' => \(my $opt_ver),

    'dev!'          => \(my $opt_dev),
    'b|build'       => \(my $opt_build),
    't|test'        => \(my $opt_test),

    'f|fast'        => \(my $opt_fast),

    'B|backup'      => \(my $opt_backup),
    'i|index!'      => \(my $opt_index),
    'up|upgrade!'   => \(my $opt_upgrade),
    'upload!'       => \(my $opt_upload),
    'delcache!'     => \(my $opt_delcache),
    'v|verbose'     => sub { $opt_verbose++ },
    'q|quiet'       => sub { $opt_verbose-- },

    'import!'       => \(my $opt_import),
    'debug!'        => \(my $opt_debug),
    'starter!'      => \(my $opt_starter),
    'clear!'        => \(my $opt_clear),
    'purge!'        => \(my $opt_purge),
    'cleantags!'    => \(my $opt_cleantags),
    'finalize!'     => \(my $opt_finalize),
) || pod2usage(2);
if ($opt_help) {
    pod2usage(1);
}
elsif ($opt_man) {
    pod2usage(-verbose => 2);
}
elsif ($opt_ver) {
    print "wg-reset - version $VERSION\n";
    exit;
}

$opt_import     = defined $opt_import       ? $opt_import
                                            : 1;
if ($opt_build) {
    $opt_dev        = defined $opt_dev          ? $opt_dev          : 0;
    $opt_verbose++;
}
elsif ($opt_test) {
    $opt_dev        = defined $opt_dev          ? $opt_dev          : 0;
    $opt_upgrade    = defined $opt_upgrade      ? $opt_upgrade      : 0;
}

$opt_fast       = defined $opt_fast         ? $opt_fast
                : !$opt_import              ? 1
                                            : 0;
$opt_dev        = defined $opt_dev          ? $opt_dev          : 1;
$opt_upgrade    = defined $opt_upgrade      ? $opt_upgrade      : 1;
$opt_upload     = defined $opt_upload       ? $opt_upload
                : $opt_fast                 ? 0
                                            : 1;
$opt_delcache   = defined $opt_delcache     ? $opt_delcache
                : $opt_fast                 ? 0
                                            : 1;

$opt_backup     = $opt_fast                 ? 0
                                            : 1;

$opt_starter    = defined $opt_starter      ? $opt_starter
                : $opt_dev                  ? 0
                : $opt_build                ? 1
                                            : undef;
$opt_debug      = defined $opt_debug        ? $opt_debug
                : $opt_dev                  ? 1
                : $opt_build                ? 0
                                            : undef;
$opt_clear      = defined $opt_clear        ? $opt_clear        : $opt_dev;

$opt_purge      = defined $opt_purge        ? $opt_purge        : $opt_upgrade;
$opt_cleantags  = defined $opt_cleantags    ? $opt_cleantags    : $opt_upgrade;
$opt_finalize   = defined $opt_finalize     ? $opt_finalize     : $opt_upgrade;

# load needed modules
unshift @INC, '/data/wre/lib';

require WRE::Config;
require Config::JSON;
require DBI;
require File::Spec;

$| = 1;

my $wg_root = WRE::Config->new->getWebguiRoot;

my $config_file = (shift @ARGV) || $ENV{WEBGUI_CONFIG} || die <<'END_ERROR';
You must set the WEBGUI_CONFIG environment variable or provide a parameter to determine which site to reset
END_ERROR
print "Loading config... " if $opt_verbose >= 1;
$config_file = File::Spec->rel2abs($config_file, $wg_root . '/etc');
my $config = Config::JSON->new($config_file);
my ($dsn, $db_name, $db_host, $db_port, $db_user, $db_pass) = get_db_info($config);
print "Done.\n" if $opt_verbose >= 1;

if ($opt_backup) {
    print "Backing up current database... " if $opt_verbose >= 1;
    system('mysqldump', "-h$db_host", "-P$db_port", $db_name, "-u$db_user", "-p$db_pass", "-r/tmp/WebGUI-reset-backup.sql");
    print "Done.\n" if $opt_verbose >= 1;
}

# Clear cache
if ($opt_delcache) {
    require Path::Class;
    print "Clearing cache... " if $opt_verbose >= 1;
    if ($config->get('cacheType') eq 'WebGUI::Cache::FileCache') {
        Path::Class::Dir->new($config->get('fileCacheRoot') || '/tmp/WebGUICache')->rmtree;
    }
    else {
        # We'd clear the DB cache here, but the whole database will be cleared in a later step
    }
    print "Done.\n" if $opt_verbose >= 1;
}
# Clear and recreate uploads
if ($opt_upload) {
    require Path::Class;
    require File::Copy;
    print "Recreating uploads... " if $opt_verbose >= 1;
    my $base_uploads = Path::Class::Dir->new($wg_root, 'www', 'uploads');
    my $site_uploads = Path::Class::Dir->new($config->get('uploadsPath'));
    $site_uploads->rmtree;
    $base_uploads->recurse(callback => sub {
        my $base_path = shift;
        #print "$base_path\n";
        my $site_path = $base_path->relative($base_uploads)->absolute($site_uploads);
        if ($site_path->is_dir) {
            for ($base_path->dir_list) {
                return
                    if $_ eq '.svn';
            }
            $site_path->mkpath;
        }
        else {
            for ($base_path->parent->dir_list) {
                return
                    if $_ eq '.svn';
            }
            #print $base_path->stringify, ' -> ', $site_path->stringify, "\n";
            File::Copy::copy($base_path->stringify, $site_path->stringify);
        }
    });
    print "Done\n" if $opt_verbose >= 1;
}

if ($opt_import) {
    # Connect using dsn and clean out old tables
    print "Clearing old database information... " if $opt_verbose >= 1;
    my $dbh = DBI->connect($dsn, $db_user, $db_pass);
    my $sth = $dbh->table_info(undef, undef, '%');
    my @tables = map {@$_} @{$sth->fetchall_arrayref([2])};
    for my $table (@tables) {
        $dbh->do('DROP TABLE ' . $dbh->quote_identifier($table));
    }
    $dbh->disconnect;
    print "Done.\n" if $opt_verbose >= 1;

    # If we aren't upgrading, we're using the current DB version
    print "Importing clean database dump... " if $opt_verbose >= 1;
    my $db_file = $opt_upgrade ? 'previousVersion.sql' : 'create.sql';
    system('mysql', "-h$db_host", "-P$db_port", $db_name, "-u$db_user", "-p$db_pass", "--batch", "--execute=source $wg_root/docs/$db_file");
    print "Done.\n" if $opt_verbose >= 1;
}

# Run the upgrade in a fork
if ($opt_upgrade) {
    print "Running upgrade script... " if $opt_verbose >= 1;
    my $pid = fork;
    unless ($pid) {
        chdir $wg_root . '/sbin';
        @ARGV = qw(--doit --override --skipBackup);
        push @ARGV, '--quiet'
            if $opt_verbose < 2;
        do 'upgrade.pl';
        exit;
    }
    waitpid $pid, 0;
    if ($?) {
        die "Upgrade failed!\n";
    }
    print "Done.\n" if $opt_verbose >= 1;
}

print "Finding current version number... " if $opt_verbose >= 1;
my $dbh = DBI->connect($dsn, $db_user, $db_pass);
my $sth = $dbh->prepare('SELECT webguiVersion FROM webguiVersion');
$sth->execute;
my @versions =
    map { $_->[0] }
    sort { $a->[1] <=> $b->[1]}
    map { [$_, version->new($_)] }
    map {@$_} @{$sth->fetchall_arrayref([0])};
$sth->finish;
my $version = pop @versions;
print "$version. Done.\n" if $opt_verbose >= 1;

if (defined $opt_debug || defined $opt_starter) {
    print "Setting WebGUI settings... " if $opt_verbose >= 1;
    $dbh = DBI->connect($dsn, $db_user, $db_pass);
    if ($opt_debug) {
        $dbh->do("REPLACE INTO settings (name, value) VALUES ('showDebug', '1')");
        $dbh->do("REPLACE INTO settings (name, value) VALUES ('sessionTimeout', '31536000')");
    }
    elsif (defined $opt_debug) {
        $dbh->do("REPLACE INTO settings (name, value) VALUES ('showDebug', '0')");
        $dbh->do("REPLACE INTO settings (name, value) VALUES ('sessionTimeout', '7200')");
    }
    if ($opt_starter) {
        $dbh->do("REPLACE INTO settings (name, value) VALUES ('specialState', 'init')");
    }
    elsif (defined $opt_starter) {
        $dbh->do("DELETE FROM settings WHERE name='specialState'");
    }
    print "Done.\n" if $opt_verbose >= 1;
}

my $wg_session;

if ($opt_clear) {
    print "Clearing example assets... " if $opt_verbose >= 1;
    print "\n" if $opt_verbose >= 2;
    $wg_session ||= wg_session($wg_root, $config_file);
    my $home = WebGUI::Asset->getDefault($wg_session);
    my $children = $home->getLineage(['descendants'], {
        statesToInclude => ['published', 'trash', 'clipboard', 'clipboard-limbo', 'trash-limbo'],
        statusToInclude => ['approved', 'pending', 'archive'],
        excludeClasses  => ['WebGUI::Asset::Wobject::Layout'],
        returnObjects   => 1,
        invertTree      => 1,
    });
    for my $child (@$children) {
        print "\tRemoving " . $child->getName . " '" . $child->get('title') . "'.\n" if $opt_verbose >= 2;
        $child->purge;
    }
    print "Done.\n" if $opt_verbose >= 1;
}

if ($opt_purge) {
    print "Purging old Asset revisions... " if $opt_verbose >= 1;
    print "\n" if $opt_verbose >= 2;
    $wg_session ||= wg_session($wg_root, $config_file);
    require WebGUI::Asset;
    my $sth = $dbh->prepare(<<END_SQL);
    SELECT assetData.assetId, asset.className, assetData.revisionDate
    FROM asset
        LEFT JOIN assetData on asset.assetId=assetData.assetId
    ORDER BY assetData.revisionDate ASC
END_SQL
    $sth->execute;
    while (my ($id, $class, $version) = $sth->fetchrow_array) {
        my $current_version = WebGUI::Asset->getCurrentRevisionDate($wg_session, $id);
        if (!defined $current_version || $current_version == $version) {
            next;
        }
        my $asset = WebGUI::Asset->new($wg_session, $id, $class, $version)
            || next;
        if ($asset->getRevisionCount("approved") > 1) {
            print sprintf("\tPurging \%-35s \%s '\%s'\n", $class, $version, $asset->get('title')) if $opt_verbose >= 2;
            $asset->purgeRevision;
        }
    }
    print "Done.\n" if $opt_verbose >= 1;
}

if ($opt_cleantags) {
    print "Cleaning out versions Tags... " if $opt_verbose >= 1;
    my $tag_id = 'pbversion0000000000001';
    my $sth = $dbh->prepare("UPDATE assetData SET tagId = ?");
    $sth->execute($tag_id);
    $sth = $dbh->prepare("DELETE FROM assetVersionTag");
    $sth->execute();
    $sth = $dbh->prepare(<<'END_SQL');
INSERT INTO `assetVersionTag`
    (tagId, name, isCommitted, creationDate, createdBy, commitDate,
    committedBy, isLocked, lockedBy, groupToUse, workflowId)
VALUES (?,?,?,?,?,?,?,?,?,?,?)
END_SQL
    $sth->execute($tag_id, "Base $version Install", 1, time(), '3', time(), '3', 0, '', '3', '');
    print "Done.\n" if $opt_verbose >= 1;
}

if ($opt_finalize) {
    print "Running all pending workflows... " if $opt_verbose >= 1;
    print "\n" if $opt_verbose >= 2;
    $wg_session ||= wg_session($wg_root, $config_file);
    require WebGUI::Workflow::Instance;
    my $sth = $dbh->prepare("SELECT instanceId FROM WorkflowInstance");
    $sth->execute;
    while (my ($instanceId) = $sth->fetchrow_array) {
        my $instance = WebGUI::Workflow::Instance->new($wg_session, $instanceId);
        while (my $result = $instance->run) {
            last
                if !($result eq 'complete' || $result eq 'waiting');
        }
    }
    print "Done.\n" if $opt_verbose >= 1;
}

$wg_session->close
    if $wg_session;

$dbh->disconnect;

if ($opt_index) {
    print "Rebuilding lineage... " if $opt_verbose >= 1;
    my $pid = fork;
    unless ($pid) {
        if ($opt_verbose < 2) {
            open STDIN,  '<', File::Spec->devnull;
            open STDOUT, '>', File::Spec->devnull;
            open STDERR, '>', File::Spec->devnull;
        }
        print "\n\n";
        chdir $wg_root . '/sbin';
        @ARGV = ('--configFile=' . $config_file);
        do './rebuildLineage.pl';
        exit;
    }
    waitpid $pid, 0;
    print "Done.\n" if $opt_verbose >= 1;

    print "Rebuilding search index... " if $opt_verbose >= 1;
    $pid = fork;
    unless ($pid) {
        if ($opt_verbose < 2) {
            open STDIN,  '<', File::Spec->devnull;
            open STDOUT, '>', File::Spec->devnull;
            open STDERR, '>', File::Spec->devnull;
        }
        print "\n\n";
        chdir $wg_root . '/sbin';
        @ARGV = ('--configFile=' . $config_file, '--indexsite');
        do './search.pl';
        exit;
    }
    waitpid $pid, 0;
    print "Done.\n" if $opt_verbose >= 1;
}

sub get_db_info {
    my $config = shift;
    my $dsn     = $config->get('dsn');
    my $db_user = $config->get('dbuser');
    my $db_pass = $config->get('dbpass');
    my $db_name = (split(/[:;]/, $dsn))[2];
    my $db_host = 'localhost';
    my $db_port = '3306';
    while ($dsn =~ /([^=;:]+)=([^;:]+)/g) {
        if ($1 eq 'host' || $1 eq 'hostname') {
            $db_host = $2;
        }
        elsif ($1 eq 'db' || $1 eq 'database' || $1 eq 'dbname') {
            $db_name = $2;
        }
        elsif ($1 eq 'port') {
            $db_port = $2;
        }
    }
    return ($dsn, $db_name, $db_host, $db_port, $db_user, $db_pass);
}

sub wg_session {
    my $wg_root = shift;
    my $wg_config = shift;
    unshift @INC, $wg_root . '/lib';
    require WebGUI::Session;
    require WebGUI::Asset;
    $wg_config = File::Spec->abs2rel($wg_config, $wg_root . '/etc');
    my $wg_session = WebGUI::Session->open($wg_root, $wg_config);
    $wg_session->user({userId => 3});
    return $wg_session;
}

__END__

=head1 NAME

wg-reset - Resets a WebGUI site to the default

=head1 SYNOPSIS

wg-reset [options] [config ...]

Options:
    --help          brief help message
    --man           full documentation

=head1 OPTIONS

=over 8

=item B<--help>

Print a brief help message and exits.

=item B<--man>

Prints the manual page and exits.

=back

=head1 DESCRIPTION

B<wg-reset> will recreate a WebGUI site from the startup database script. This
includes running upgrade scripts as needed and recreating the uploads directory.
There are also options for setting various options useful for development and
creating a new database import script.

=cut

