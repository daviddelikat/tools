#!/usr/bin/env perl
unless (caller) {
    require WGDev::Command;
    WGDev::Command->run(@ARGV);
}

BEGIN {
    $INC{'WGDev.pm'} = __FILE__;
    $INC{'WGDev/Asset.pm'} = __FILE__;
    $INC{'WGDev/Command.pm'} = __FILE__;
    $INC{'WGDev/Command/Base.pm'} = __FILE__;
    $INC{'WGDev/Command/Base/Verbosity.pm'} = __FILE__;
    $INC{'WGDev/Command/Build.pm'} = __FILE__;
    $INC{'WGDev/Command/Db.pm'} = __FILE__;
    $INC{'WGDev/Command/Dist.pm'} = __FILE__;
    $INC{'WGDev/Command/Edit.pm'} = __FILE__;
    $INC{'WGDev/Command/Package.pm'} = __FILE__;
    $INC{'WGDev/Command/Reset.pm'} = __FILE__;
    $INC{'WGDev/Command/Run.pm'} = __FILE__;
    $INC{'WGDev/Command/Test.pm'} = __FILE__;
    $INC{'WGDev/Command/Version.pm'} = __FILE__;
    $INC{'WGDev/Database.pm'} = __FILE__;
    $INC{'WGDev/Help.pm'} = __FILE__;
    $INC{'WGDev/Version.pm'} = __FILE__;
}

{
package WGDev;
use strict;
use warnings;
use 5.008008;

our $VERSION = '0.2.0';

use File::Spec ();
use Cwd        ();
use Carp qw(croak);

sub new {
    my ( $class, $root, $config ) = @_;
    my $self = bless {}, $class;
    if ( $config && -e $config ) {

        # file exists as is, save absolute path
        $self->{config_file} = $config = File::Spec->rel2abs($config);
    }
    if ($root) {
        $self->{root} = $root;
    }
    else {
        if ( $config && -e $config ) {
            my $config_dir = File::Spec->catpath(
                ( File::Spec->splitpath($config) )[ 0, 1 ] );
            $self->{root} = Cwd::realpath(
                File::Spec->catdir( $config_dir, File::Spec->updir ) );
        }
        else {
            my $dir = Cwd::getcwd();
            while (1) {
                if (
                    -e File::Spec->catfile(
                        $dir, 'etc', 'WebGUI.conf.original'
                    ) )
                {
                    $self->{root} = $dir;
                    last;
                }
                my $parent = Cwd::realpath(
                    File::Spec->catdir( $dir, File::Spec->updir ) );
                last
                    if $dir eq $parent;
                $dir = $parent;
            }
        }
    }
    if ( $self->{root} ) {
        if ( !$config ) {
            if ( opendir my $dh, File::Spec->catdir( $self->{root}, 'etc' ) )
            {
                my @configs = readdir $dh;
                closedir $dh
                    or croak "Unable to close directory handle: $!";
                @configs = grep {
                    /\Q.conf\E$/msx
                        && !/^(?:spectre|log)\Q.conf\E$/msx
                } @configs;
                if ( @configs == 1 ) {
                    $config = $configs[0];
                }
            }
        }
        if ($config) {
            $self->{config_file}
                ||= File::Spec->catfile( $self->{root}, 'etc', $config );
        }
        $self->{lib} = File::Spec->catdir( $self->{root}, 'lib' );
    }
    else {
        croak 'Unable to determine webgui root!';
    }

    $self->set_environment;

    return $self;
}

sub set_environment {
    my $self = shift;
    $ENV{WEBGUI_ROOT}   = $self->root;
    $ENV{WEBGUI_CONFIG} = $self->config_file;
    unshift @INC, $self->lib;
    $ENV{PERL5LIB} = $ENV{PERL5LIB}
        ? do {
        require Config;
        $self->lib . $Config::Config{path_sep} . $ENV{PERL5LIB};
        }
        : $self->lib;
    return 1;
}

sub root        { return shift->{root} }
sub config_file { return shift->{config_file} }
sub lib         { return shift->{lib} }

sub config {
    my $self = shift;
    croak 'no config file available'
        if !$self->{config_file};
    return $self->{config} ||= do {
        require Config::JSON;
        Config::JSON->new( $self->config_file );
    };
}

sub close_config {
    my $self = shift;
    delete $self->{config};

    # if we're closing the config, we probably want new sessions to pick up
    # changes to the file
    ## no critic (Modules::RequireExplicitInclusion)
    if ( WebGUI::Config->can('clearCache') ) {
        WebGUI::Config->clearCache;
    }
    return 1;
}

sub config_file_relative {
    my $self = shift;
    return $self->{config_file_relative} ||= do {
        my $config_dir
            = Cwd::realpath( File::Spec->catdir( $self->root, 'etc' ) );
        File::Spec->abs2rel( Cwd::realpath( $self->config_file ),
            $config_dir );
    };
}

sub db {
    my $self = shift;
    require WGDev::Database;
    return $self->{db} ||= WGDev::Database->new( $self->config );
}

sub session {
    my $self = shift;
    require WebGUI::Session;
    if ( $self->{session} ) {
        my $dbh = $self->{session}->db->dbh;

        # evil, but we have to detect if the database handle died somehow
        if ( !$dbh->ping ) {
            ( delete $self->{session} )->close;
        }
    }
    return $self->{session} ||= do {
        my $session
            = WebGUI::Session->open( $self->root, $self->config_file_relative,
            undef, undef, $self->{session_id} );
        $self->{session_id} = $session->getId;
        $session;
    };
}

sub close_session {
    my $self = shift;
    if ( $self->{session} ) {    # if we have a cached session
        my $session = $self->session;  # get the session, recreating if needed
        $session->var->end;            # close the session
        $session->close;
        delete $self->{session};
    }
    return 1;
}

sub asset {
    my $self = shift;
    require WGDev::Asset;
    return $self->{asset} ||= WGDev::Asset->new( $self->session );
}

sub version {
    my $self = shift;
    require WGDev::Version;
    return $self->{version} ||= WGDev::Version->new( $self->root );
}

sub wgd_config {
    my $self      = shift;
    my $namespace = shift;
    my $key       = shift;
    my $config    = $self->{wgd_config};
    if ( !$config ) {
        for my $config_file ( '.wgdevcfg', $ENV{HOME} . '/.wgdevcfg' ) {
            if ( -e $config_file ) {
                open my $fh, '<', $config_file or next;
                my $content = do { local $/ = undef; <$fh> };
                close $fh or next;
                $self->{wgd_config} = $config = yaml_decode($content);
            }
        }
    }
    if ( !$config ) {
        return;
    }
    if ($namespace) {
        my $ns_config = $config->{$namespace};
        if ( !$ns_config ) {
            return;
        }
        if ($key) {
            return $ns_config->{$key};
        }
        return $ns_config;
    }
    else {
        return $config;
    }
}

sub my_config {    ## no critic (RequireArgUnpacking)
    my ($self)   = shift;
    my ($caller) = caller;
    return $self->wgd_config( $caller, @_ );
}

sub yaml_decode {
    ## no critic (RequireFinalReturn ProhibitCascadingIfElse ProhibitNoWarnings)
    my $decode;
    if ( eval { require YAML::XS } ) {
        $decode = \&YAML::XS::Load;
    }
    elsif ( eval { require YAML::Syck } ) {
        $decode = \&YAML::Syck::Load;
    }
    elsif ( eval { require YAML } ) {
        $decode = \&YAML::Load;
    }
    elsif ( eval { require YAML::Tiny } ) {
        $decode = \&YAML::Tiny::Load;
    }
    else {
        $decode = sub {
            die "No YAML library available!\n";
        };
    }
    no warnings 'redefine';
    *yaml_decode = $decode;
    goto &{$decode};
}

sub yaml_encode {
    ## no critic (RequireFinalReturn ProhibitCascadingIfElse ProhibitNoWarnings)
    my $encode;
    if ( eval { require YAML::XS } ) {
        $encode = \&YAML::XS::Dump;
    }
    elsif ( eval { require YAML::Syck } ) {
        $encode = \&YAML::Syck::Dump;
    }
    elsif ( eval { require YAML } ) {
        $encode = \&YAML::Dump;
    }
    elsif ( eval { require YAML::Tiny } ) {
        $encode = \&YAML::Tiny::Dump;
    }
    else {
        $encode = sub {
            die "No YAML library available!\n";
        };
    }
    no warnings 'redefine';
    *yaml_encode = $encode;
    goto &{$encode};
}

sub DESTROY {
    my $self = shift;
    $self->close_session;
    return;
}

1;

}
{
package WGDev::Asset;
use strict;
use warnings;
use 5.008008;

our $VERSION = '0.0.1';

use constant LINE_LENGTH => 78;

use WGDev;

sub new {
    my $class   = shift;
    my $session = shift;
    my $self    = bless { session => $session, }, $class;
    require WebGUI::Asset;
    return $self;
}

sub root {
    my $self = shift;
    return WebGUI::Asset->getRoot( $self->{session} );
}

sub import_node {
    my $self = shift;
    return WebGUI::Asset->getImportNode( $self->{session} );
}
sub default_asset { goto &home }

sub home {
    my $self = shift;
    return WebGUI::Asset->getDefault( $self->{session} );
}

sub by_url {    ## no critic (RequireArgUnpacking)
    my $self = shift;
    return WebGUI::Asset->newByUrl( $self->{session}, @_ );
}

sub by_id {     ## no critic (RequireArgUnpacking)
    my $self = shift;
    return WebGUI::Asset->new( $self->{session}, @_ );
}

sub serialize {
    my ( $self, $asset ) = @_;
    my $class       = ref $asset;
    my $short_class = $class;
    $short_class =~ s/^WebGUI::Asset:://xms;
    my $definition = $class->definition( $asset->session );
    my %text;
    my %meta;
    my $asset_properties = $asset->get;
    my $parent_url       = $asset->getParent->get('url');
    my $header           = "==== $short_class ";
    $header .= ( q{=} x ( LINE_LENGTH - length $header ) ) . "\n";
    my $output = $header . <<"END_COMMON";
Asset ID     : $asset_properties->{assetId}
Title        : $asset_properties->{title}
# Menu Title : $asset_properties->{menuTitle}
# URL        : $asset_properties->{url}
# Parent URL : $parent_url
END_COMMON

    for my $def ( @{$definition} ) {
        while ( my ( $property, $property_def )
            = each %{ $def->{properties} } )
        {
            my $field_type = ucfirst $property_def->{fieldType};
            if (   $property eq 'title'
                || $property eq 'menuTitle'
                || $property eq 'url' )
            {
                next;
            }
            elsif ($field_type eq 'HTMLArea'
                || $field_type eq 'Textarea'
                || $field_type eq 'Codearea' )
            {
                $text{$property} = $asset_properties->{$property};
            }
            elsif ( $field_type eq 'Hidden' ) {
                next;
            }
            else {
                $meta{ $property_def->{tab} || 'properties' }{$property}
                    = $asset_properties->{$property};
            }
        }
    }
    while ( my ( $field, $value ) = each %text ) {
        if ( !defined $value ) {
            $value = q{~};
        }
        $value =~ s/\r\n/\n/msxg;
        $value =~ s/\r/\n/msxg;
        $header = "==== $field ";
        $header .= ( q{=} x ( LINE_LENGTH - length $header ) ) . "\n";
        $output .= $header . ( defined $value ? $value : q{~} ) . "\n";
    }
    $header = '==== Properties ';
    $header .= ( q{=} x ( LINE_LENGTH - length $header ) ) . "\n";
    $output .= $header;
    my $meta_yaml = WGDev::yaml_encode( \%meta );
    $meta_yaml =~ s/\A---(?:\Q {}\E)?\n?//msx;
    $output .= $meta_yaml . "\n";
    return $output;
}

sub deserialize {
    my $self          = shift;
    my $asset_data    = shift;
    my @text_sections = split m{
        ^====[ ]    # line start, plus equal signs
        ((?:\w|:)+) # word chars or colons (Perl namespace)
        [ ]=+       # space + equals
        (?:\n|\z)   # end of line or end of string
    }msx, $asset_data;
    shift @text_sections;
    my $class      = shift @text_sections;
    my $basic_data = shift @text_sections;
    my %sections;
    my %properties;

    while ( my $section = shift @text_sections ) {
        my $section_data = shift @text_sections;
        chomp $section_data;
        if ( $section_data eq q{~} ) {
            $section_data = undef;
        }
        $sections{$section} = $section_data;
    }
    if ( my $prop_data = delete $sections{Properties} ) {
        my $tabs = WGDev::yaml_decode($prop_data);
        %properties = map { %{$_} } values %{$tabs};
    }
    %properties = ( %properties, %sections );
    for my $line ( split /\n/msx, $basic_data ) {
        next
            if $line =~ /\A\s*#/msx;
        if (
            $line =~ m{
            ^\s*
            ([^:]+?)
            \s*:\s*
            (.*?)
            \s*$
        }msx
            )
        {
            my $prop
                = $1 eq 'Title'      ? 'title'
                : $1 eq 'Asset ID'   ? 'assetId'
                : $1 eq 'Menu Title' ? 'menuTitle'
                : $1 eq 'URL'        ? 'url'
                : $1 eq 'Parent URL' ? 'parent_url'
                :                      undef;
            if ($prop) {
                $properties{$prop} = $2;
            }
        }
    }

    return \%properties;
}

1;

}
{
package WGDev::Command;
use strict;
use warnings;
use 5.008008;

our $VERSION = '0.1.1';

use Getopt::Long ();
use File::Spec   ();
use Cwd          ();
use Carp qw(croak carp);
##no critic (RequireCarping)

sub run {    ##no critic (RequireArgUnpacking)
    my $class = shift;
    local @ARGV = @_;
    Getopt::Long::Configure(qw(default gnu_getopt pass_through));
    Getopt::Long::GetOptions(
        'h|?|help'      => \( my $opt_help ),
        'V|ver|version' => \( my $opt_version ),

        'F|config-file=s' => \( my $opt_config = $ENV{WEBGUI_CONFIG} ),
        'R|webgui-root=s' => \( my $opt_root   = $ENV{WEBGUI_ROOT} ),
    ) || warn $class->usage && exit 1;
    my @params = @ARGV;

    my $command_name = shift @params;

    my $command_module = _find_cmd_module($command_name);
    if ( $command_name && !$command_module ) {
        my $command_exec = _find_cmd_exec($command_name);
        if ($command_exec) {
            require WGDev;
            WGDev->new( $opt_root, $opt_config )->set_environment;
            exec {$command_exec} $command_exec, $opt_help ? '--help' : (),
                $opt_version ? '--version' : (), @_;
        }
        else {
            warn $class->usage(
                message          => "Can't find command $command_name!\n",
                include_cmd_list => 1
            );
            exit 2;
        }
    }

    if ($opt_version) {
        $class->report_version( $command_name, $command_module );
    }
    elsif ($opt_help) {
        $class->report_help( $command_name, $command_module );
    }
    elsif ( !$command_name ) {
        warn $class->usage(
            message          => "No command specified!\n",
            include_cmd_list => 1
        );
        exit 1;
    }
    else {
        require WGDev;
        my $wgd = WGDev->new( $opt_root, $opt_config );
        if (
            !eval {
                my $command = $command_module->new($wgd);
                $command->run(@params);
                1;
            } )
        {
            carp $@;
            exit 1;
        }
    }
    exit;
}

sub report_version {
    my ( $class, $name, $module ) = @_;
    if ( ref $class ) {
        $class = ref $class;
    }
    print "$class version " . $class->VERSION;
    if ($module) {
        print " - $module version " . $module->VERSION;
    }
    print "\n";
    return 1;
}

sub report_help {
    my ( $class, $name, $module ) = @_;
    if ( ref $class ) {
        $class = ref $class;
    }
    if ($module) {
        if ( $module->can('usage') ) {
            print $module->usage;
        }
        else {
            carp "No documentation for $name command.\n";
        }
    }
    else {
        print $class->usage;
    }
    return 1;
}

sub _find_cmd_module {
    my $command_name = shift;
    if ( $command_name && $command_name =~ /^[-\w]+$/mxs ) {
        my $module = join q{::}, __PACKAGE__, map {ucfirst} split /-/msx,
            $command_name;
        ( my $module_file = "$module.pm" ) =~ s{::}{/}mxsg;
        if (   eval { require $module_file; 1 }
            && $module->can('run')
            && $module->can('is_runnable')
            && $module->is_runnable )
        {
            return $module;
        }
    }
    return;
}

sub _find_cmd_exec {
    my ( $command_name, $root, $config ) = @_;
    if ($command_name) {
        for my $path ( File::Spec->path ) {
            my $execpath = File::Spec->catfile( $path, "wgd-$command_name" );
            if ( -x $execpath ) {
                return $execpath;
            }
        }
    }
    return;
}

sub usage {
    my $class = shift;
    require WGDev::Help;
    my $message = WGDev::Help::package_usage( $class, 2 );

    $message .= "SUBCOMMANDS\n";
    for my $command ( $class->command_list ) {
        $message .= "    $command\n";
    }
    $message .= "\n";
    return $message;
}

sub command_list {
    my $class = shift;
    my %commands;
    ( my $fn_prefix = $class ) =~ s{::}{/}msxg;

    require File::Find;
    my %lib_check;
    for my $inc_path (@INC) {
        ##no critic (ProhibitParensWithBuiltins)
        my $command_root
            = File::Spec->catdir( $inc_path, split( /::/msx, $class ) );
        next
            if !-d $command_root;
        my $find_callback = sub {
            return
                if !/\Q.pm\E$/msx;

            no warnings 'once';    ##no critic (ProhibitNoWarnings)
            my $lib_path
                = File::Spec->abs2rel( $File::Find::name, $inc_path );
            $lib_check{$lib_path} = 1;
        };
        File::Find::find( { no_chdir => 1, wanted => $find_callback },
            $command_root );
    }
    for my $module ( grep {m{^$fn_prefix/}msx} keys %INC ) {
        $lib_check{$module} = 1;
    }
    for my $module ( keys %lib_check ) {
        my $package = $module;
        $package =~ s/\Q.pm\E$//msx;
        $package = join q{::}, File::Spec->splitdir($package);
        if (
            eval {
                require $module;
                $package->can('run')
                    && $package->can('is_runnable')
                    && $package->is_runnable;
            } )
        {
            ( my $command = $package ) =~ s/^\Q$class\E:://msx;
            $command = join q{-}, map {lcfirst} split m{::}msx, $command;
            $commands{$command} = 1;
        }
    }

    for my $command ( map { glob "$_/wgd-*" } File::Spec->path ) {
        next
            if !-x $command;
        my $file = ( File::Spec->splitpath($command) )[2];
        $file =~ s/^wgd-//msx;
        $commands{$file} = 1;
    }
    my @commands = sort keys %commands;
    return @commands;
}

1;

}
{
package WGDev::Command::Base;
use strict;
use warnings;
use 5.008008;

our $VERSION = '0.0.1';
##no critic (RequireArgUnpacking);

sub is_runnable {
    my $class = shift;
    return $class->can('process');
}

sub new {
    my ( $class, $wgd ) = @_;
    my $self = bless {
        wgd       => $wgd,
        options   => {},
        arguments => [],
    }, $class;
    return $self;
}

sub wgd { return $_[0]->{wgd} }

sub parse_params {
    my $self = shift;
    local @ARGV = @_;
    require Getopt::Long;
    Getopt::Long::Configure( 'default', $self->option_parse_config );
    my $result
        = Getopt::Long::GetOptions( $self->{options}, $self->option_config );
    @{ $self->{arguments} } = @ARGV;
    return $result;
}

sub option_parse_config { return qw(gnu_getopt) }
sub option_config       { }

sub option {
    my $self = shift;
    my $option = shift || return;
    if (@_) {
        return $self->{options}{$option} = shift;
    }
    return $self->{options}{$option};
}

sub option_default {
    my $self = shift;
    my $option = shift || return;
    if ( !defined $self->option($option) ) {
        return $self->option( $option, @_ );
    }
    return;
}

sub arguments {
    return @{ $_[0]->{arguments} };
}

sub run {
    my $self = shift;
    my @params = ( @_ == 1 && ref $_[0] eq 'ARRAY' ) ? @{ +shift } : @_;
    local $| = 1;
    if ( !$self->parse_params(@params) ) {
        my $usage = $self->usage(0);
        warn $usage;    ##no critic (RequireCarping)
        exit 1;
    }
    my $result = $self->process ? 0 : 1;
    exit $result;
}

sub usage {
    my $class     = shift;
    my $verbosity = shift;
    if ( ref $class ) {
        $class = ref $class;
    }
    require WGDev::Help;
    my $usage = WGDev::Help::package_usage( $class, $verbosity );
    return $usage;
}

1;

}
{
package WGDev::Command::Base::Verbosity;
use strict;
use warnings;
use 5.008008;

our $VERSION = '0.1.0';

use WGDev::Command::Base;
BEGIN { our @ISA = qw(WGDev::Command::Base) }

sub new {    ##no critic (RequireArgUnpacking)
    my $class = shift;
    my $self  = $class->SUPER::new(@_);
    $self->{verbosity} = 1;
    return $self;
}

sub option_config {
    return qw(
        verbose|v+
        quiet|q+
    );
}

sub parse_params {    ##no critic (RequireArgUnpacking)
    my $self   = shift;
    my $result = $self->SUPER::parse_params(@_);
    $self->{verbosity} += ( $self->option('verbose') || 0 )
        - ( $self->option('quiet') || 0 );
    return $result;
}

sub verbosity {       ##no critic (RequireArgUnpacking)
    my $self = shift;
    if (@_) {
        return $self->{verbosity} = shift;
    }
    return $self->{verbosity};
}

sub report {
    my $self          = shift;
    my $message       = pop;
    my $verbose_limit = shift;
    if ( !defined $verbose_limit ) {
        $verbose_limit = 1;
    }
    return
        if $verbose_limit > $self->verbosity;
    print $message;
    return 1;
}

1;

}
{
package WGDev::Command::Build;
use strict;
use warnings;
use 5.008008;

our $VERSION = '0.1.0';

use WGDev::Command::Base::Verbosity;
BEGIN { our @ISA = qw(WGDev::Command::Base::Verbosity) }

use File::Spec ();
use Carp qw(croak);

sub option_config {
    return (
        shift->SUPER::option_config, qw(
            sql|s
            uploads|u
            ) );
}

sub parse_params {    ##no critic (RequireArgUnpacking)
    my $self   = shift;
    my $result = $self->SUPER::parse_params(@_);
    if ( !defined $self->option('sql') && !defined $self->option('uploads') )
    {
        $self->option( 'sql',     1 );
        $self->option( 'uploads', 1 );
    }
    return $result;
}

sub process {
    my $self = shift;
    my $wgd  = $self->wgd;
    require File::Copy;
    if ( !$wgd->config_file ) {
        die "Can't find WebGUI root!\n";
    }

    if ( $self->option('sql') ) {
        $self->create_db_script;
    }

    if ( $self->option('uploads') ) {
        $self->update_local_uploads;
    }
    return 1;
}

sub create_db_script {
    my $self = shift;
    my $wgd  = $self->wgd;
    require File::Copy;

    $self->report('Finding current version number... ');
    my $version = $wgd->version->database( $wgd->db->connect );
    $self->report("$version. Done.\n");

    $self->report('Creating database dump... ');
    my $db_file = File::Spec->catfile( $wgd->root, 'docs', 'create.sql' );
    ##no critic (RequireBriefOpen)
    open my $out, q{>}, $db_file
        or croak "Unable to output database script: $!";
    open my $in, q{-|}, 'mysqldump',
        $wgd->db->command_line( '--compact', '--no-data' )
        or croak "Unable to run mysqldump: $!";
    File::Copy::copy( $in, $out );
    close $in or croak "Unable to close filehandle: $!";

    my @skip_data_tables = qw(
        userSession     userSessionScratch
        webguiVersion   userLoginLog
        assetHistory    cache
    );
    open $in, q{-|}, 'mysqldump', $wgd->db->command_line(
        '--compact',
        '--no-create-info',
        map { '--ignore-table=' . $wgd->db->database . q{.} . $_ }
            @skip_data_tables
    ) or croak "Unable to run mysqldunp command: $!";
    File::Copy::copy( $in, $out );
    close $in or croak "Unable to close filehandle: $!";

    print {$out} 'INSERT INTO webguiVersion '
        . '(webguiVersion,versionType,dateApplied) '
        . "VALUES ('$version','Initial Install',UNIX_TIMESTAMP());\n";

    close $out or croak "Unable to close filehandle: $!";
    $self->report("Done.\n");
    return 1;
}

sub update_local_uploads {
    my $self = shift;
    my $wgd  = $self->wgd;
    require File::Find;
    require File::Path;
    require File::Copy;

    $self->report('Loading uploads from site... ');
    my $wg_uploads = File::Spec->catdir( $wgd->root, 'www', 'uploads' );
    File::Path::mkpath($wg_uploads);
    my $site_uploads    = $wgd->config->get('uploadsPath');
    my $remove_files_cb = sub {
        no warnings 'once';    ##no critic (ProhibitNoWarnings)
        my $wg_path = $File::Find::name;
        my ( undef, undef, $filename ) = File::Spec->splitpath($wg_path);
        if ( $filename eq '.svn' || $filename eq 'temp' ) {
            $File::Find::prune = 1;
            return;
        }
        my $rel_path = File::Spec->abs2rel( $wg_path, $wg_uploads );
        my $site_path = File::Spec->rel2abs( $rel_path, $site_uploads );
        return
            if -e $site_path;
        if ( -d $site_path ) {
            File::Path::rmtree($wg_path);
        }
        else {
            unlink $wg_path;
        }
    };
    File::Find::find( { no_chdir => 1, wanted => $remove_files_cb },
        $wg_uploads );
    my $copy_files_cb = sub {
        no warnings 'once';    ##no critic (ProhibitNoWarnings)
        my $site_path = $File::Find::name;
        my ( undef, undef, $filename ) = File::Spec->splitpath($site_path);
        if ( $filename eq '.svn' || $filename eq 'temp' ) {
            $File::Find::prune = 1;
            return;
        }
        return
            if -d $site_path;
        my $rel_path = File::Spec->abs2rel( $site_path, $site_uploads );
        my $wg_path = File::Spec->rel2abs( $rel_path, $wg_uploads );

        # stat[7] is file size
        ##no critic (ProhibitMagicNumbers)
        return
            if -e $wg_path && ( stat _ )[7] == ( stat $site_path )[7];
        my $wg_dir = File::Spec->catpath(
            ( File::Spec->splitpath($wg_path) )[ 0, 1 ] );
        File::Path::mkpath($wg_dir);
        File::Copy::copy( $site_path, $wg_path );
    };
    File::Find::find( { no_chdir => 1, wanted => $copy_files_cb },
        $site_uploads );
    $self->report("Done\n");
    return 1;
}

1;

}
{
package WGDev::Command::Db;
use strict;
use warnings;

our $VERSION = '0.1.0';

use WGDev::Command::Base;
BEGIN { our @ISA = qw(WGDev::Command::Base) }

sub option_config { qw(
    print|p
    dump|d:s
    load|l=s
    clear|c
)}

sub option_parse_config { qw(gnu_getopt pass_through) }

sub process {
    my $self = shift;
    my $db = $self->wgd->db;
    my @command_line = $db->command_line($self->arguments);
    if (  (defined $self->option('print')   || 0)
        + (defined $self->option('dump')    || 0)
        + (defined $self->option('load')    || 0)
        + (defined $self->option('clear')   || 0) > 1) {
        die "Multiple database operations specified!\n";
    }

    if ($self->option('print')) {
        print join " ", map {"'$_'"} @command_line
    }
    elsif ($self->option('clear')) {
        $db->clear;
    }
    elsif (defined $self->option('load')) {
        if ($self->option('load') && $self->option('load') ne '-') {
            $db->load($self->option('load'));
        }
        else {
            exec {'mysql'} 'mysql', @command_line;
        }
    }
    elsif (defined $self->option('dump')) {
        if ($self->option('dump') && $self->option('dump') ne '-') {
            $db->dump($self->option('dump'));
        }
        else {
            exec {'mysqldump'} 'mysqldump', @command_line;
        }
    }
    else {
        exec {'mysql'} 'mysql', @command_line;
    }
}

1;

}
{
package WGDev::Command::Dist;
use strict;
use warnings;
use 5.008008;

our $VERSION = '0.1.0';

use WGDev::Command::Base;
BEGIN { our @ISA = qw(WGDev::Command::Base) }

sub process {
    require File::Temp;
    require File::Copy;
    require Cwd;
    my $self = shift;
    my $wgd = $self->wgd;

    my ($version, $status) = $wgd->version->module;
    my $build_root = File::Temp->newdir;
    my $build_webgui = File::Spec->catdir($build_root, 'WebGUI');
    my $build_docs = File::Spec->catdir($build_root, 'api');
    my $cwd = Cwd::cwd();

    mkdir $build_webgui;
    $self->export_files($build_webgui);
    unless (fork()) {
        chdir $build_root;
        exec 'tar', 'czf', File::Spec->catfile($cwd, "webgui-$version-$status.tar.gz"), 'WebGUI';
    }
    wait;

    mkdir $build_docs;
    $self->generate_docs($build_docs);
    unless (fork()) {
        chdir $build_root;
        exec 'tar', 'czf', File::Spec->catfile($cwd, "webgui-api-$version-$status.tar.gz"), 'api';
    }
    wait;
}

sub export_files {
    my $self = shift;
    my $from = $self->wgd->root;
    my $to_root = shift;

    if (-e File::Spec->catdir($from, '.git')) {
        system 'git', '--git-dir=' . File::Spec->catdir($from, '.git'), 'checkout-index', '-a', '--prefix=' . $to_root . '/';
    }
    elsif (-e File::Spec->catdir($from, '.svn')) {
        system 'svn', 'export', $from, $to_root;
    }
    else {
        system 'cp', '-r', $from, $to_root;
    }

    for my $file ( ['docs', 'previousVersion.sql'], ['etc', '*.conf'],
                   ['sbin', 'preload.custom'], ['sbin', 'preload.exclude'] ) {
        my $file_path = File::Spec->catfile($to_root, @$file);
        unlink $_
            for glob $file_path;
    }
    return $to_root;
}

sub generate_docs {
    require File::Find;
    require File::Path;
    require Pod::Html;
    require File::Temp;
    my $self = shift;
    my $from = $self->wgd->root;
    my $to_root = shift;
    my $code_dir = File::Spec->catdir($from, 'lib', 'WebGUI');
    my $temp_dir = File::Temp->newdir;
    File::Find::find({
        no_chdir    => 1,
        wanted      => sub {
            no warnings 'once';
            my $code_file = $File::Find::name;
            return
                if -d $code_file;
            my $doc_file = $code_file;
            return
                if $doc_file =~ /\bOperation\.pm$/;
            return
                unless $doc_file =~ s/\.pm$/.html/;
            $doc_file = File::Spec->rel2abs(File::Spec->abs2rel($doc_file, $code_dir), $to_root);
            my $directory = File::Spec->catpath( (File::Spec->splitpath($doc_file))[0,1] );
            File::Path::mkpath($directory);
            Pod::Html::pod2html(
                '--quiet',
                '--noindex',
                '--infile=' . $code_file,
                '--outfile=' . $doc_file,
                '--cachedir=' . $temp_dir,
            );
        },
    }, $code_dir);
    return $to_root;
}

1;

}
{
package WGDev::Command::Edit;
use strict;
use warnings;
use 5.008008;

our $VERSION = '0.1.0';

use WGDev::Command::Base;
BEGIN { our @ISA = qw(WGDev::Command::Base) }

sub option_config {qw(
    command=s
)}

sub process {
    my $self = shift;
    my $wgd = $self->wgd;

    require WebGUI::Asset;
    require File::Temp;

    my @files;
    for my $asset_spec ( $self->arguments ) {
        my $asset;
        if (! ($asset_spec =~ m{/}msx)) {
            $asset = $wgd->asset->by_id($asset_spec);
        }
        if (! $asset) {
            $asset = $wgd->asset->by_url($asset_spec);
        }
        if (! $asset) {
            warn "$asset_spec is not a valid asset!\n";
            next;
        }
        my $file_data = $self->write_temp($asset);
        if (! $file_data) {
            next;
        }
        push @files, $file_data;
    }
    unless (@files) {
        die "No assets to edit!\n";
    }

    my $command = $self->option('command') || $ENV{EDITOR} || 'vi';
    system($command . ' ' . join(' ', map { $_->{filename} } @files));

    my $versionTag;
    for my $file (@files) {
        if ((stat($file->{filename}))[9] <= $file->{mtime}) {
            warn "Skipping " . $file->{asset}->get('url') . ", not changed.\n";
            unlink $file->{filename};
            next;
        }
        $versionTag ||= do {
            my $vt = WebGUI::VersionTag->getWorking($wgd->session);
            $vt->set({name=>"WGDev Asset Editor"});
            $vt;
        };
        open my $fh, '<:utf8', $file->{filename} || next;
        my $asset_text = do { local $/; <$fh> };
        close $fh;
        unlink $file->{filename};
        my $asset_data = $wgd->asset->deserialize($asset_text);
        $file->{asset}->addRevision($asset_data);
    }

    if ($versionTag) {
        $versionTag->commit;
    }
    return 1;
}

sub write_temp {
    my $self = shift;
    my $asset = shift;

    my ($fh, $filename) = File::Temp::tempfile();
    binmode $fh, ':utf8';
    print {$fh} $self->wgd->asset->serialize($asset);
    close $fh or return;
    return {
        asset       => $asset,
        filename    => $filename,
        mtime       => (stat($filename))[9],
    };
}

1;

}
{
package WGDev::Command::Package;
use strict;
use warnings;
use 5.008008;

our $VERSION = '0.2.0';

use WGDev::Command::Base;
BEGIN { our @ISA = qw(WGDev::Command::Base) }

use Carp qw(croak);

sub option_config { qw(
    import|i=s@
    parent-id=s
    parent-url=s

    guid|assetId|asset-id|id=s@
    upgrade|u
    output-dir|out-dir=s
)}

sub process {
    my $self = shift;
    my $wgd = $self->wgd;
    require File::Copy;
    if ($self->arguments || $self->option('guid')) {
        my $package_dir = $self->option('output-dir') || '.';
        if ($self->option('upgrade')) {
            $package_dir = File::Spec->catdir($wgd->root, 'docs', 'upgrades', 'packages-' . $wgd->version->module);
            if (! -d $package_dir) {
                mkdir $package_dir;
            }
        }
        if (! -d $package_dir) {
            croak "$package_dir does not exist!\n";
        }
        my @assets;
        for my $url ($self->arguments) {
            my $asset = $wgd->asset->by_url($url);
            if ($asset) {
                push @assets, $asset
            }
            else {
                warn "Unable to find asset with url $url!\n";
            }
        }
        if ($self->option('guid')) {
            for my $asset_id (@{ $self->option('guid') }) {
                my $asset = $wgd->asset->by_id($asset_id);
                if ($asset) {
                    push @assets, $asset
                }
                else {
                    warn "Unable to find asset with id $asset_id!\n";
                }
            }
        }
        for my $asset (@assets) {
            my $storage = $asset->exportPackage;
            my $filename = $storage->getFiles->[0];
            my $filepath = $storage->getPath($filename);
            File::Copy::copy($filepath, File::Spec->catfile($package_dir, $filename));
            printf "Building package %26s for '%26s'.\n", $filename, $asset->get('title');
        }
    }
    if ($self->option('import')) {
        require WebGUI::Storage;
        my $parent
            = $self->option('parent-id')    ? $wgd->asset->by_id($self->option('parent-id'))
            : $self->option('parent-url')   ? $wgd->asset->by_url($self->option('parent-url'))
            : $wgd->asset->import_node
            ;
        if (! $parent) {
            warn "Unable to find parent node!\n";
            return 0;
        }
        my $versionTag = WebGUI::VersionTag->getWorking($wgd->session);
        $versionTag->set({name => 'WGDev package import'});
        for my $package (@{ $self->option('import')}) {
            my $storage = WebGUI::Storage->createTemp($wgd->session);
            $storage->addFileFromFilesystem($package);
            my $asset = $parent->importPackage($storage);
            print "Imported '$package' to " . $asset->get('url') . "\n";
        }
        $versionTag->commit;
    }
    return 1;
}

1;

}
{
package WGDev::Command::Reset;
use strict;
use warnings;

our $VERSION = '0.1.1';

use WGDev::Command::Base::Verbosity;
BEGIN { our @ISA = qw(WGDev::Command::Base::Verbosity) }

use File::Spec ();

sub option_config {
    (shift->SUPER::option_config, qw(
        fast|f

        backup!
        delcache!
        import!

        test|t
        dev|d
        build|b

        uploads!
        upgrade!

        debug!
        starter!
        clear!
        purge!
        cleantags!
        index!
        runwf!
    ))
}

sub parse_params {
    my $self = shift;
    my $result = $self->SUPER::parse_params(@_);

    if ($self->option('fast')) {
        $self->option_default(backup    => 1);
        $self->option_default(uploads   => 0);
        $self->option_default(backup    => 0);
        $self->option_default(delcache  => 0);
        $self->option_default(purge     => 0);
        $self->option_default(cleantags => 0);
        $self->option_default(index     => 0);
        $self->option_default(runwf     => 0);
    }
    if ($self->option('dev')) {
        $self->option_default(backup    => 1);
        $self->option_default(import    => 1);
        $self->option_default(uploads   => 1);
        $self->option_default(upgrade   => 1);
        $self->option_default(starter   => 0);
        $self->option_default(debug     => 1);
        $self->option_default(clear     => 1);
    }
    if ($self->option('build')) {
        $self->verbosity($self->verbosity + 1);
        $self->option_default(backup    => 1);
        $self->option_default(uploads   => 1);
        $self->option_default(import    => 1);
        $self->option_default(starter   => 1);
        $self->option_default(debug     => 0);
        $self->option_default(upgrade   => 1);
        $self->option_default(purge     => 1);
        $self->option_default(cleantags => 1);
        $self->option_default(index     => 1);
        $self->option_default(runwf     => 1);
    }
    $self->option_default('delcache', 1);
    return $result;
}

sub process {
    my $self = shift;
    my $wgd = $self->wgd;

    if ($self->option('backup')) {
        $self->backup;
    }

    # Clear cache
    if ($self->option('delcache')) {
        $self->clear_cache;
    }

    # Clear and recreate uploads
    if ($self->option('uploads')) {
        $self->reset_uploads;
    }

    if ($self->option('import')) {
        $self->import_db_script;
    }

    # Run the upgrade in a fork
    if ($self->option('upgrade')) {
        $self->upgrade;
    }

    if (defined $self->option('debug') || defined $self->option('starter')) {
        $self->set_settings;
    }

    if ($self->option('clear')) {
        $self->clear_default_content;
    }

    if ($self->option('purge')) {
        $self->purge_old_revisions;
    }

    if ($self->option('cleantags')) {
        $self->clean_version_tags;
    }

    if ($self->option('runwf')) {
        $self->run_all_workflows;
    }

    if ($self->option('index')) {
        $self->rebuild_lineage;
        $self->rebuild_index;
    }

    return 1;
}

sub backup {
    my $self = shift;
    $self->report("Backing up current database... ");
    $self->wgd->db->dump(File::Spec->catfile(File::Spec->tmpdir, 'WebGUI-reset-backup.sql'));
    $self->report("Done.\n");
    return 1;
}

sub clear_cache {
    my $self = shift;
    my $wgd = $self->wgd;
    require File::Path;
    $self->report("Clearing cache... ");
    if ($wgd->config->get('cacheType') eq 'WebGUI::Cache::FileCache') {
        my $cache_dir = $wgd->config->get('fileCacheRoot') || '/tmp/WebGUICache';
        File::Path::rmtree($cache_dir);
    }
    elsif ($wgd->config->get('cacheType') eq 'WebGUI::Cache::Database') {
        # Don't clear the DB cache if we are importing, as that will wipe it anyway
        unless ($self->option('import')) {
            my $dsn = $wgd->db->connect;
            $dsn->do('DELETE FROM cache');
        }
    }
    else {
        # Can't clear a cache we don't know anything about
    }
    $self->report("Done.\n");
    return 1;
}

# Clear and recreate uploads
sub reset_uploads {
    my $self = shift;
    my $wgd = $self->wgd;
    require File::Copy;
    require File::Find;
    require File::Path;
    $self->report("Recreating uploads... ");

    my $wg_uploads = File::Spec->catdir($wgd->root, 'www', 'uploads');
    my $site_uploads = $wgd->config->get('uploadsPath');
    File::Path::rmtree($site_uploads);
    File::Find::find({
        no_chdir    => 1,
        wanted      => sub {
            no warnings 'once';
            my $wg_path = $File::Find::name;
            my $site_path = File::Spec->rel2abs(File::Spec->abs2rel($wg_path, $wg_uploads), $site_uploads);
            if (-d $wg_path) {
                my $dir = (File::Spec->splitdir($wg_path))[-1];
                if ($dir =~ /^\./) {
                    $File::Find::prune = 1;
                    return;
                }
                File::Path::mkpath($site_path);
            }
            else {
                File::Copy::copy($wg_path, $site_path);
            }
        },
    }, $wg_uploads);
    $self->report("Done\n");
    return 1;
}

sub import_db_script {
    my $self = shift;
    my $wgd = $self->wgd;
    $self->report("Clearing old database information... ");
    $wgd->db->clear;
    $self->report("Done.\n");

    $self->report("Importing clean database dump... ");
    # If we aren't upgrading, we're using the current DB version
    my $db_file = $self->option('upgrade') ? 'previousVersion.sql' : 'create.sql';
    $wgd->db->load(File::Spec->catfile($wgd->root, 'docs', $db_file));
    $self->report("Done\n");
    return 1;
}

# Run the upgrade in a fork
sub upgrade {
    my $self = shift;
    my $wgd = $self->wgd;
    $self->report("Running upgrade script... ");
    # todo: only upgrade single site
    my $pid = fork;
    unless ($pid) {
        # child process, don't need to worry about restoring anything
        chdir File::Spec->catdir($wgd->root, 'sbin');
        @ARGV = qw(--doit --override --skipBackup);
        push @ARGV, '--quiet'
            if $self->verbosity < 2;
        do 'upgrade.pl';
        die $@ if $@;
        exit;
    }
    waitpid $pid, 0;
    if ($?) {
        die "Upgrade failed!\n";
    }
    $self->report("Done\n");
    return 1;
}

sub set_settings {
    my $self = shift;
    my $wgd = $self->wgd;
    $self->report("Setting WebGUI settings... ");
    my $dbh = $wgd->db->connect;
    my $sth = $dbh->prepare("REPLACE INTO `settings` (`name`, `value`) VALUES (?,?)");
    if ($self->option('debug')) {
        $sth->execute('showDebug', 1);
        $sth->execute('sessionTimeout', 31536000);
    }
    elsif (defined $self->option('debug')) {
        $sth->execute('showDebug', 0);
        $sth->execute('sessionTimeout', 7200);
    }
    if ($self->option('starter')) {
        $sth->execute('specialState', 'init');
    }
    elsif (defined $self->option('starter')) {
        $dbh->do("DELETE FROM `settings` WHERE `name`='specialState'");
    }
    $self->report("Done\n");
    return 1;
}

sub clear_default_content {
    my $self = shift;
    my $wgd = $self->wgd;
    $self->report("Clearing example assets... ");
    $self->report(2, "\n");
    my $home = $wgd->asset->home;
    my $children = $home->getLineage(['descendants'], {
        statesToInclude => ['published', 'trash', 'clipboard', 'clipboard-limbo', 'trash-limbo'],
        statusToInclude => ['approved', 'pending', 'archive'],
        excludeClasses  => ['WebGUI::Asset::Wobject::Layout'],
        returnObjects   => 1,
        invertTree      => 1,
    });
    for my $child (@$children) {
        $self->report(2, sprintf "\tRemoving \%-35s '\%s'\n", $child->getName, $child->get('title'));
        $child->purge;
    }
    $self->report("Done\n");
    return 1;
}

sub purge_old_revisions {
    my $self = shift;
    my $wgd = $self->wgd;
    require WebGUI::Asset;
    $self->report("Purging old Asset revisions... ");
    $self->report(2, "\n");
    my $sth = $wgd->db->connect->prepare(<<END_SQL);
    SELECT assetData.assetId, asset.className, assetData.revisionDate
    FROM asset
        LEFT JOIN assetData on asset.assetId=assetData.assetId
    ORDER BY assetData.revisionDate ASC
END_SQL
    $sth->execute;
    while (my ($id, $class, $revision) = $sth->fetchrow_array) {
        my $current_revision = WebGUI::Asset->getCurrentRevisionDate($wgd->session, $id);
        if (!defined $current_revision || $current_revision == $revision) {
            next;
        }
        my $asset = WebGUI::Asset->new($wgd->session, $id, $class, $revision)
            || next;
        if ($asset->getRevisionCount("approved") > 1) {
            $self->report(2, sprintf "\tPurging \%-35s \%s '\%s'\n", $asset->getName, $revision, $asset->get('title'));
            $asset->purgeRevision;
        }
    }
    $self->report("Done\n");
    return 1;
}

sub clean_version_tags {
    my $self = shift;
    my $wgd = $self->wgd;

    $self->report("Finding current version number... ");
    my $version = $wgd->version->database($wgd->db->connect);
    $self->report("$version. Done\n");

    $self->report("Cleaning out versions Tags... ");
    my $tag_id = 'pbversion0000000000001';
    my $dbh = $wgd->db->connect;
    my $sth = $dbh->prepare("UPDATE `assetData` SET `tagId` = ?");
    $sth->execute($tag_id);
    $sth = $dbh->prepare("DELETE FROM `assetVersionTag`");
    $sth->execute;
    $sth = $dbh->prepare(<<'END_SQL');
        INSERT INTO `assetVersionTag`
            ( `tagId`, `name`, `isCommitted`, `creationDate`, `createdBy`, `commitDate`,
                `committedBy`, `isLocked`, `lockedBy`, `groupToUse`, `workflowId` )
        VALUES (?,?,?,?,?,?,?,?,?,?,?)
END_SQL
    my $now = time;
    $sth->execute($tag_id, "Base $version Install", 1, $now, '3', $now, '3', 0, '', '3', '');
    $self->report("Done\n");
    return 1;
}

sub run_all_workflows {
    my $self = shift;
    my $wgd = $self->wgd;
    $self->report("Running all pending workflows... ");
    $self->report(2, "\n");
    require WebGUI::Workflow::Instance;
    my $sth = $wgd->db->connect->prepare("SELECT instanceId FROM WorkflowInstance");
    $sth->execute;
    while (my ($instanceId) = $sth->fetchrow_array) {
        my $instance = WebGUI::Workflow::Instance->new($wgd->session, $instanceId);
        my $waiting_count = 0;
        while (my $result = $instance->run) {
            if ($result eq 'complete') {
                $waiting_count = 0;
                next;
            }
            if ($result eq 'waiting') {
                if ($waiting_count++ > 10) {
                    warn "Unable to finish workflow " . $instanceId . ", too many iterations!\n";
                    last;
                }
                next;
            }
            if ($result eq 'done') {
            }
            elsif ($result eq 'error') {
                warn "Unable to finish workflow " . $instanceId . ".  Error!\n";
            }
            else {
                warn "Unable to finish workflow " . $instanceId . ".  Unknown status $result!\n";
            }
            last;
        }
    }
    $self->report("Done\n");
    return 1;
}

sub rebuild_lineage {
    my $self = shift;
    my $wgd = $self->wgd;
    $self->report("Rebuilding lineage... ");
    my $pid = fork;
    unless ($pid) {
        if ($self->verbosity < 3) {
            open STDIN,  '<', File::Spec->devnull;
            open STDOUT, '>', File::Spec->devnull;
            open STDERR, '>', File::Spec->devnull;
        }
        print "\n\n";
        chdir File::Spec->catdir($wgd->root, 'sbin');
        @ARGV = ('--configFile=' . $wgd->config_file_relative);
        $0 = './rebuildLineage.pl';
        do $0;
        exit;
    }
    waitpid $pid, 0;
    $self->report("Done\n");
    return 1;
}

sub rebuild_index {
    my $self = shift;
    my $wgd = $self->wgd;
    $self->report("Rebuilding search index... ");
    my $pid = fork;
    unless ($pid) {
        if ($self->verbosity < 3) {
            open STDIN,  '<', File::Spec->devnull;
            open STDOUT, '>', File::Spec->devnull;
            open STDERR, '>', File::Spec->devnull;
        }
        print "\n\n";
        chdir File::Spec->catdir($wgd->root, 'sbin');
        @ARGV = ('--configFile=' . $wgd->config_file_relative, '--indexsite');
        $0 = './search.pl';
        do $0;
        exit;
    }
    waitpid $pid, 0;
    $self->report("Done\n");
    return 1;
}

1;

}
{
package WGDev::Command::Run;
use strict;
use warnings;

our $VERSION = '0.0.1';

use WGDev::Command::Base;
BEGIN { our @ISA = qw(WGDev::Command::Base) }

sub process {
    my $self = shift;
    $self->wgd->set_environment;
    exec $self->arguments;
}

sub parse_params {
    my $self = shift;
    @{ $self->{arguments} } = @_;
    return 1;
}

1;

}
{
package WGDev::Command::Test;
use strict;
use warnings;

our $VERSION = '0.0.1';

use WGDev::Command::Base;
BEGIN { our @ISA = qw(WGDev::Command::Base) }

use File::Spec ();

sub option_parse_config { qw(gnu_getopt pass_through) }

sub option_config {qw(
    all|A
    slow|S
)}


sub process {
    my $self = shift;
    my $wgd = $self->wgd;
    require Cwd;
    require App::Prove;
    if ($self->option('slow')) {
        $ENV{CODE_COP}      = 1;
        $ENV{TEST_SYNTAX}   = 1;
        $ENV{TEST_POD}      = 1;
    }
    my $prove = App::Prove->new;
    my @args = $self->arguments;
    my $orig_dir;
    if ($self->option('slow')) {
        $orig_dir = Cwd::cwd();
        chdir $wgd->root;
        unshift @args, '-r', 't';
    }
    $prove->process_args(@args);
    my $result = $prove->run;
    chdir $orig_dir
        if $orig_dir;
    return $result;
}

1;

}
{
package WGDev::Command::Version;
use strict;
use warnings;

our $VERSION = '0.1.0';

use WGDev::Command::Base;
BEGIN { our @ISA = qw(WGDev::Command::Base) }

sub option_parse_config { qw(no_getopt_compat) };
sub option_config {qw(
    create|c
    bare|b
)}

sub process {
    my $self = shift;
    my $wgd = $self->wgd;

    my ($ver) = $self->arguments;

    my $wgv = $wgd->version;
    if ($self->option('create')) {
        my $root = $wgd->root;
        my $old_version = $wgv->module;
        my $new_version = $ver || do {
            my @parts = split /\./, $old_version;
            $parts[-1]++;
            join '.', @parts;
        };

        open my $fh, '<', File::Spec->catfile($root, 'lib', 'WebGUI.pm');
        my @pm_content = do { local $/; <$fh> };
        close $fh;
        open $fh, '>', File::Spec->catfile($root, 'lib', 'WebGUI.pm');
        for my $line (@pm_content) {
            $line =~ s/(\$VERSION\s*=).*;/$1 '$new_version';/;
            print {$fh} $line;
        }
        close $fh;

        my ($change_file) = $wgv->changelog;
        my $change_content = do {
            open my $fh, '<', File::Spec->catfile($root, 'docs', 'changelog', $change_file);
            local $/;
            <$fh>;
        };
        open $fh, '>', File::Spec->catfile($root, 'docs', 'changelog', $change_file);
        print {$fh} $new_version . "\n\n" . $change_content;
        close $fh;

        open my $in, '<', File::Spec->catfile($root, 'docs', 'upgrades', '_upgrade.skeleton');
        open my $out, '>', File::Spec->catfile($root, 'docs', 'upgrades', "upgrade_$old_version-$new_version.pl");
        while (my $line = <$in>) {
            $line =~ s/(\$toVersion\s*=).*$/$1 '$new_version';/;
            print {$out} $line;
        }
        close $out;
        close $in;
    }

    my ($perl_version, $perl_status) = $wgv->module;
    if ($self->option('bare')) {
        print $perl_version, "\n";
        return 1;
    }

    my $db_version = $wgv->database_script;
    my ($change_file, $change_version) = $wgv->changelog;
    my ($up_file, undef, $up_file_ver, $up_version) = $wgv->upgrade;

    my $err_count = 0;
    my $expect_ver = $ver || $perl_version;
    if ($perl_version ne $expect_ver) {
        $err_count++;
        $perl_version = colored($perl_version, 'bold red')
    }
    if ($db_version ne $expect_ver) {
        $err_count++;
        $db_version = colored($db_version, 'bold red')
    }
    if ($change_version ne $expect_ver) {
        $err_count++;
        $change_version = colored($change_version, 'bold red')
    }
    if ($up_version ne $expect_ver) {
        $err_count++;
        $up_version = colored($up_version, 'bold red')
    }
    if ($up_file_ver ne $expect_ver) {
        $err_count++;
        $up_file = colored($up_file, 'bold red')
    }

    print <<END_REPORT;
  Perl version:             $perl_version - $perl_status
  Database version:         $db_version
  Changelog version:        $change_version
  Upgrade script version:   $up_version
  Upgrade script filename:  $up_file
END_REPORT

    print colored("\n  Version numbers don't match!\n", 'bold red')
        if $err_count;
    return 1;
}

sub colored {
    no warnings 'redefine';
    if (eval { require Term::ANSIColor; 1 }) {
        *colored = \&Term::ANSIColor::colored;
    }
    else {
        *colored = sub {$_[0]};
    }
    goto &colored;
}

1;

}
{
package WGDev::Database;
use strict;
use warnings;
use 5.008008;

our $VERSION = '0.0.1';

use Carp qw(croak);

sub username { return shift->{username} }
sub password { return shift->{password} }
sub database { return shift->{database} }
sub hostname { return shift->{hostname} }
sub port     { return shift->{port} }
sub dsn      { return shift->{dsn} }

sub user { goto &username }
sub pass { goto &password }
sub host { goto &hostname }
sub name { goto &database }

sub new {
    my $class  = shift;
    my $config = shift;
    my $self   = bless {}, $class;

    my $dsn = $self->{dsn} = $config->get('dsn');
    $self->{username} = $config->get('dbuser');
    $self->{password} = $config->get('dbpass');
    $self->{database} = ( split /[:;]/msx, $dsn )[2];
    $self->{hostname} = 'localhost';
    $self->{port}     = '3306';
    while ( $dsn =~ /([^=;:]+)=([^;:]+)/msxg ) {
        if ( $1 eq 'host' || $1 eq 'hostname' ) {
            $self->{hostname} = $2;
        }
        elsif ( $1 eq 'db' || $1 eq 'database' || $1 eq 'dbname' ) {
            $self->{database} = $2;
        }
        elsif ( $1 eq 'port' ) {
            $self->{port} = $2;
        }
    }
    return $self;
}

sub command_line {    ## no critic (RequireArgUnpacking)
    my $self   = shift;
    my @params = (
        '-h' . $self->hostname,
        '-P' . $self->port,
        $self->database,
        '-u' . $self->username,
        ( $self->password ? '-p' . $self->password : () ),
        @_,
    );
    return wantarray ? @params : join q{ }, map {"'$_'"} @params;
}

sub connect {    ## no critic (ProhibitBuiltinHomonyms)
    my $self = shift;
    require DBI;
    if ( $self->{dbh} && !$self->{dbh}->ping ) {
        delete $self->{dbh};
    }
    return $self->{dbh} ||= DBI->connect(
        $self->dsn,
        $self->username,
        $self->password,
        {
            RaiseError        => 1,
            PrintWarn         => 0,
            PrintError        => 0,
            mysql_enable_utf8 => 1
        } );
}
sub dbh  { return shift->{dbh} }
sub open { goto &connect }         ## no critic (ProhibitBuiltinHomonyms)

sub disconnect {
    my $self = shift;
    if ( my $dbh = delete $self->{dbh} ) {
        $dbh->disconnect;
    }
    return;
}

sub close {    ## no critic (ProhibitBuiltinHomonyms ProhibitAmbiguousNames)
    goto &disconnect;
}

sub clear {
    my $self   = shift;
    my $dbh    = $self->connect;
    my $sth    = $dbh->table_info( undef, undef, q{%} );
    my @tables = map { @{$_} } @{ $sth->fetchall_arrayref( [2] ) };
    for my $table (@tables) {
        $dbh->do( 'DROP TABLE ' . $dbh->quote_identifier($table) );
    }
    return 1;
}

sub load {
    my $self     = shift;
    my $dumpfile = shift;
    $self->clear;
    system 'mysql', $self->command_line( '-e' . 'source ' . $dumpfile )
        and croak "Error running mysql: $!";
    return 1;
}

sub dump {    ## no critic (ProhibitBuiltinHomonyms)
    my $self     = shift;
    my $dumpfile = shift;
    system 'mysqldump', $self->command_line( '-r' . $dumpfile )
        and croak "Error running mysqldump: $!";
    return 1;
}

1;

}
{
package WGDev::Help;
use strict;
use warnings;
use 5.008008;

our $VERSION = '0.0.1';

use Carp qw(croak);

sub package_usage {
    my $package   = shift;
    my $verbosity = shift;
    require Pod::Usage;
    if ( !defined $verbosity ) {
        $verbosity = 1;
    }
    ( my $file = $package . '.pm' ) =~ s{::}{/}msxg;
    require $file;
    my $actual_file = $INC{$file};
    my $pod         = filter_pod( $actual_file, $package );
    my $output      = q{};
    ##no critic (RequireCarping RequireBriefOpen)
    open my $out, '>', \$output
        or die "Can't open file handle to scalar : $!";
    open my $in, '<', \$pod or croak "Unable to read documentation file : $!";
    my $params = {
        -input   => $in,
        -output  => $out,
        -exitval => 'NOEXIT',
        -verbose => $verbosity,
    };
    Pod::Usage::pod2usage($params);
    close $in  or return q{};
    close $out or return q{};
    return $output;
}

# naive pod filter.  looks for =head1 NAME section that has the correct
# package listed, and returns the text from there to the next =head1 NAME
sub filter_pod {
    my $file   = shift;
    my $wanted = shift;
    open my $fh, '<', $file or return q{};
    my $content = do { local $/ = undef; <$fh> };
    close $fh or return q{};
    if ( $content
        =~ /^(=head1[ ]NAME\s+^\Q$wanted\E\s.*?)(?:^=head1[ ]NAME\E\s|\z)/msx
        )
    {
        return $1;
    }
    return q{};
}

1;

}
{
package WGDev::Version;
use strict;
use warnings;
use 5.008008;

our $VERSION = '0.1.0';

use File::Spec;
use Carp qw(croak);

sub new {
    my $class = shift;
    my $dir   = shift || croak 'Must specify WebGUI base directory!';
    my $self  = bless \$dir, $class;
    return $self;
}

sub pm { goto &module }

sub module {
    my $dir = ${ +shift };
    my $version;
    my $status;
    ##no critic (RequireBriefOpen)
    open my $fh, '<', File::Spec->catfile( $dir, 'lib', 'WebGUI.pm' )
        or croak "Unable to read WebGUI.pm module: $!";
    while ( my $line = <$fh> ) {
        ##no critic (ProhibitStringyEval)
        if ( $line =~ /\$VERSION\s*=(.*)$/msx ) {
            $version = eval $1;
        }
        if ( $line =~ /\$STATUS\s*=(.*)$/msx ) {
            $status = eval $1;
        }
        last
            if $version && $status;
    }
    close $fh or croak "Unable to close filehandle: $!";
    return wantarray ? ( $version, $status ) : $version;
}

sub db_script { goto &database_script }

sub database_script {
    my $dir = ${ +shift };
    my $version;
    ##no critic (RequireBriefOpen)
    open my $fh, '<', File::Spec->catfile( $dir, 'docs', 'create.sql' )
        or croak "Unable to read create.sql script: $!";
    while ( my $line = <$fh> ) {
        if (
            $line =~ m{
            (?:(?i)\QINSERT INTO\E) \s+
            (`?)webguiVersion\1     \s+
            .+?                     \s+?
            (?i)VALUES              \s+
            \Q('\E ( [^']+ )        [']
            }msx
            )
        {
            $version = $2;
            last;
        }
    }
    close $fh or croak "Unable to close filehandle: $!";
    return $version;
}

sub db { goto &database }

sub database {
    my $dir = ${ +shift };
    my $dbh = shift;
    require version;
    my $sth = $dbh->prepare('SELECT webguiVersion FROM webguiVersion');
    $sth->execute;
    my @versions = map { $_->[0] }
        sort { $a->[1] <=> $b->[1] }
        map { [ $_, version->new($_) ] }
        map { @{$_} } @{ $sth->fetchall_arrayref( [0] ) };
    $sth->finish;
    my $version = pop @versions;
    return $version;
}

sub changelog {
    my $dir = ${ +shift };
    require version;
    my @changelogs;
    opendir my $dh, File::Spec->catdir( $dir, 'docs', 'changelog' )
        or croak "Unable to list changelogs: $!";
    while ( my $file = readdir $dh ) {
        if ( $file =~ /^( [x\d]+ [.] [x\d]+ [.] [x\d]+ ) \Q.txt\E $/msx ) {
            ( my $v = $1 ) =~ tr/x/0/;
            push @changelogs, [ $file, version->new($v) ];
        }
    }
    closedir $dh
        or croak "Unable to close directory handle: $!";
    @changelogs = sort { $a->[1] <=> $b->[1] } @changelogs;
    my $latest = pop @changelogs;
    open my $fh, '<',
        File::Spec->catfile( $dir, 'docs', 'changelog', $latest->[0] )
        or croak "Unable to read changelog: $!";
    while ( my $line = <$fh> ) {
        if ( $line =~ /^(\d+\.\d+\.\d+)$/msx ) {
            $latest->[1] = $1;
            last;
        }
    }
    close $fh or croak "Unable to close filehandle: $!";
    return @{$latest};
}

# returns ($upgrade_file, $from_version, $to_version, $to_version_file)
sub upgrade {
    my $dir = ${ +shift };
    require version;
    my @upgrades;
    opendir my $dh, File::Spec->catdir( $dir, 'docs', 'upgrades' )
        or croak "Unable to list upgrades: $!";
    while ( my $file = readdir $dh ) {
        if ( $file =~ /^upgrade_ ([.\d]+) - ([.\d]+) \Q.pl\E$/msx ) {
            push @upgrades, [ $file, version->new($1), version->new($2) ];
        }
    }
    closedir $dh
        or croak "Unable to close directory handle: $!";
    @upgrades = sort { $a->[2] <=> $b->[2] } @upgrades;
    my $latest = pop @upgrades;
    open my $fh, '<',    ##no critic (RequireBriefOpen)
        File::Spec->catfile( $dir, 'docs', 'upgrades', $latest->[0] )
        or croak "Unable to read upgrade script: $!";
    while ( my $line = <$fh> ) {
        if ( $line =~ /\$toVersion\s*=(.*)$/msx ) {
            ##no critic (ProhibitStringyEval RequireCheckingReturnValueOfEval)
            push @{$latest}, eval $1;
            last;
        }
    }
    close $fh or croak "Unable to close filehandle: $!";
    return @{$latest};
}

1;

}
__END__

=head1 NAME

WGDev - WebGUI Developer Utilities

=head1 SYNOPSIS

    use WGDev;

    my $wgd = WGDev->new( $webgui_root, $config_file );

    my $webgui_session = $wgd->session;
    my $webgui_version = $wgd->version->module;

=head1 DESCRIPTION

Performs common actions needed by WebGUI developers, such as recreating their
site from defaults, checking version numbers, exporting packages, and more.

=head1 AUTHOR

Graham Knop <graham@plainblack.com>

=head1 LICENSE

Copyright (c) Graham Knop.  All rights reserved.

This library is free software; you can redistribute it and/or modify it under
the same terms as Perl itself.

=cut


=head1 NAME

WGDev::Asset - Asset utility functions

=head1 SYNOPSIS

    my $root_node = $wgd->asset->root;

=head1 DESCRIPTION

Performs common actions on assets

=head1 AUTHOR

Graham Knop <graham@plainblack.com>

=head1 LICENSE

Copyright (c) Graham Knop.  All rights reserved.

This library is free software; you can redistribute it and/or modify it under
the same terms as Perl itself.

=cut


=head1 NAME

WGDev::Command - Run WGDev commands

=head1 SYNOPSIS

wgd [arguments] <subcommand> [subcommand arguments]

=head1 DESCRIPTION

Runs subcommands from the WGDev::Command namespace, or standalone scripts starting with wgd-

=head1 OPTIONS

=over 8

=item B<-h -? --help>

Display help for any command.

=item B<-V --version>

Display version information

=item B<-F --config-file>

Specify WebGUI config file to use.  Can be absolute, relative to
the current directory, or relative to WebGUI's config directory.
If not specified, it will try to use the WEBGUI_CONFIG environment
variable.  If that is not set and there is only one config file
in WebGUI's config directory, that file will be used.

=item B<-R --webgui-root>

Specify WebGUI's root directory.  Can be absolute or relative.
If not specified, first the WEBGUI_ROOT environment variable will
be checked, then will search upward from the current path for a
WebGUI installation.

=item B<E<lt>subcommandE<gt>>

Subcommand to run or get help for.

=back

=head1 AUTHOR

Graham Knop <graham@plainblack.com>

=head1 LICENSE

Copyright (c) Graham Knop.  All rights reserved.

This library is free software; you can redistribute it and/or modify it under
the same terms as Perl itself.

=cut


=head1 NAME

WGDev::Command::Base - Super-class for implementing WGDev commands

=head1 SYNOPSIS

    package WGDev::Command::Mine;
    use WGDev::Command::Base;
    @ISA = qw(WGDev::Command::Base);

    sub process {
        my $self = shift;
        print "Running my command\n";
        return 1;
    }

=head1 DESCRIPTION

A super-class useful for implementing WGDev command modules.  Includes simple
methods to override for parameter parsing and provides help text via
Pod::Usage.

=head1 METHODS

=head2 is_runnable

Must return true for the command to be run by WGDev::Command.

=head1 AUTHOR

Graham Knop <graham@plainblack.com>

=head1 LICENSE

Copyright (c) Graham Knop.  All rights reserved.

This library is free software; you can redistribute it and/or modify it under
the same terms as Perl itself.

=cut


=head1 NAME

WGDev::Command::Base::Verbosity - Super-class for implementing WGDev commands with verbosity levels

=head1 SYNOPSIS

    package WGDev::Command::Mine;
    use WGDev::Command::Base::Verbisity;
    @ISA = qw(WGDev::Command::Base::Verbosity);

    sub process {
        my $self = shift;
        $self->report("Running my command\n");
        return 1;
    }

=head1 DESCRIPTION

A super-class useful for implementing WGDev command modules.  Includes simple
methods to override for parameter parsing and provides help text via
Pod::Usage.

=head1 AUTHOR

Graham Knop <graham@plainblack.com>

=head1 LICENSE

Copyright (c) Graham Knop.  All rights reserved.

This library is free software; you can redistribute it and/or modify it under
the same terms as Perl itself.

=cut


=head1 NAME

WGDev::Command::Build - Builds an SQL script and uploads for site creation

=head1 SYNOPSIS

wgd build [-s] [-u]

=head1 DESCRIPTION

Uses the current database and uploads to build a new create.sql and update
the local uploads directory.  With no options, builds both sql and uploads.

=head1 OPTIONS

=over 8

=item B<-s --sql>

make create.sql based on current database contents

=item B<-u --uploads>

make uploads based on current site's uploads

=back

=head1 AUTHOR

Graham Knop <graham@plainblack.com>

=head1 LICENSE

Copyright (c) Graham Knop.  All rights reserved.

This library is free software; you can redistribute it and/or modify it under
the same terms as Perl itself.

=cut


=head1 NAME

WGDev::Command::Db - Connect to database with mysql

=head1 SYNOPSIS

wgd db [-p | -d | -l | -c] [mysql options]

=head1 DESCRIPTION

Opens the mysql client to your WebGUI database, loads or dumps a database script, or clears a database's contents.

=head1 OPTIONS

Any arguments not recognized will be passed through to the mysql or mysqldump commands in applicable.

=over 8

=item B<-p --print>

Prints out the command options that would be passed to mysql

=item B<-d --dump>

Dumps the database as an SQL script.  If a file is specified,
dumps to that file.  Otherwise, dumps to standard out.

=item B<-l --load>

Loads a database script into the database.  Database script must be specified.

=item B<-c --clear>

Clears the database, removing all tables.

=back

=head1 AUTHOR

Graham Knop <graham@plainblack.com>

=head1 LICENSE

Copyright (c) Graham Knop.  All rights reserved.

This library is free software; you can redistribute it and/or modify it under
the same terms as Perl itself.

=cut


=head1 NAME

WGDev::Command::Dist - Create a distribution file for WebGUI

=head1 SYNOPSIS

wgd dist [-c] [-d]

=head1 DESCRIPTION

Generates distribution files containing WebGUI or the WebGUI API.

=head1 OPTIONS

By default, generates both a code and API documentation package.

=over 8

=item B<-c --code>

Generates a code distrobution

=item B<-d --documentation>

Generates an API documentation distribution

=back

=head1 AUTHOR

Graham Knop <graham@plainblack.com>

=head1 LICENSE

Copyright (c) Graham Knop.  All rights reserved.

This library is free software; you can redistribute it and/or modify it under
the same terms as Perl itself.

=cut


=head1 NAME

WGDev::Command::Edit - Edits assets by URL

=head1

wgd edit [--command=<command>] <asset> [<asset> ...]

=head1 DESCRIPTION

Exports asset to temporary files, then opens them in your prefered editor.
If modifications are made, the assets are updated.

=head1 OPTIONS

=over 8

=item B<--command>

Command to be executed.  If not specified, uses the EDITOR environment
variable.  If that is not specified, uses vi.

=item B<E<lt>assetE<gt>>

Either a URL or an asset ID of an asset.  As many can be specified as desired.
Prepending with a slash will force it to be interpreted as a URL.

=back

=head1 AUTHOR

Graham Knop <graham@plainblack.com>

=head1 LICENSE

Copyright (c) Graham Knop.  All rights reserved.

This library is free software; you can redistribute it and/or modify it under
the same terms as Perl itself.

=cut


=head1 NAME

WGDev::Command::Package - Export assets for upgrade

=head1 SYNOPSIS

    wgd package [--output-dir=<dir>] [--upgrade] [<asset url> ...] [--guid=<asset id> ...]
    wgd package [--parent-id=<asset id>] [--parent-url=<asset url>] [--import=<package file>]

=head1 DESCRIPTION

Exports assets as packages to the current version's upgrade location.

=head1 OPTIONS

=over 8

=item B<--import -i>

Package file (or files) to import.  Will be imported to the import node if no
other parent is specified.

=item B<--parent-id>

Specify the parent to import packages to as an asset ID.

=item B<--parent-url>

Specify the parent to import packages to as an asset URL.

=item B<--guid --assetId --asset-id --id>

Specify assets to export by their asset ID.

=item B<--upgrade -u>

If specified, packages will be exported to the directory for the upgrade to
the current local version.

=item B<--output-dir --out-dir>

Specify a directory to output the package files to.  If neither --upgrade or
--output-dir is specified, packages will be output to the current directory.

=item B<E<lt>asset urlE<gt>>

Any other parameters will be assumed to be asset URLs to export as packages.

=back

=head1 AUTHOR

Graham Knop <graham@plainblack.com>

=head1 LICENSE

Copyright (c) Graham Knop.  All rights reserved.

This library is free software; you can redistribute it and/or modify it under
the same terms as Perl itself.

=cut


=head1 NAME

WGDev::Command::Reset - Reset a site to defaults

=head1 SYNOPSIS

wgd reset [-v] [-q] [-f] [-d | -b | -t]

=head1 DESCRIPTION

Resets a site to defaults, including multiple cleanup options for setting up
a site for development or for a build.  Can also perform the cleanup functions
without resetting a site.

=head1 OPTIONS

=over 8

=item B<-v --verbose>

Output more information

=item B<-q --quiet>

Output less information

=item B<-f --fast>

Fast mode - equivalent to:
--no-upload --no-backup --no-delcache --no-purge --no-cleantags --no-index
--no-runwf

=item B<-t --test>

Test mode - equivalent to:
--backup --import

=item B<-d --dev>

Developer mode - equivalent to:
--backup --import --no-starter --debug --clear --upgrade --uploads

=item B<-b --build>

Build mode - equivalent to:
--verbose --backup --import --starter --no-debug --upgrade --purge --cleantags
--index --runwf

=item B<--backup --no-backup>

Backup database before doing any other operations.  Defaults to on.

=item B<--delcache --no-delcache>

Delete the site's cache.  Defaults to on.

=item B<--import --no-import>

Import a database script

=item B<--uploads --no-uploads>

Recreate uploads directory

=item B<--upgrade --no-upgrade>

Perform an upgrade - also controls which DB script to import

=item B<--debug --no-debug>

Enable debug mode and increase session timeout

=item B<--starter --no-starter>

Enable the site starter

=item B<--clear --no-clear>

Clear the content off the home page and its children

=item B<--purge --no-purge>

Purge all old revisions

=item B<--cleantags --no-cleantags>

Removes all version tags and sets all asset revisions to be
under a new version tag marked with the current version number

=item B<--index --no-index>

Rebuild the site lineage and reindex all of the content

=item B<--runwf --no-runwf>

Attempt to finish any running workflows

=back

=head1 AUTHOR

Graham Knop <graham@plainblack.com>

=head1 LICENSE

Copyright (c) Graham Knop.  All rights reserved.

This library is free software; you can redistribute it and/or modify it under
the same terms as Perl itself.

=cut


=head1 NAME

WGDev::Command::Run - Run arbitrary shell command

=head1 SYNOPSIS

wgd run <command>

=head1 DESCRIPTION

Runs an arbitrary command, but sets the WEBGUI_CONFIG, WEBGUI_ROOT, and
PERL5LIB environment variables first.

=head1 OPTIONS

Has no options of its own.  All options are passed on to specified command.

=head1 AUTHOR

Graham Knop <graham@plainblack.com>

=head1 LICENSE

Copyright (c) Graham Knop.  All rights reserved.

This library is free software; you can redistribute it and/or modify it under
the same terms as Perl itself.

=cut


=head1 NAME

WGDev::Command::Test - Run WebGUI tests

=head1 SYNOPSIS

wgd test [-AS] [<prove options>]

=head1 DESCRIPTION

Runs WebGUI tests, setting the needed environment variables beforehand.
Includes quick options for running all tests, and including slow tests.

=head1 OPTIONS

Unrecognized options will be passed through to prove.

=over 8

=item B<-A --all>

Run all tests recursively.  Otherwise, tests will need to be specified.

=item B<-S --slow>

Includes slow tests by defining CODE_COP, TEST_SYNTAX, and TEST_POD.

=back

=head1 AUTHOR

Graham Knop <graham@plainblack.com>

=head1 LICENSE

Copyright (c) Graham Knop.  All rights reserved.

This library is free software; you can redistribute it and/or modify it under
the same terms as Perl itself.

=cut



=head1 NAME

WGDev::Command::Version - Reports and updates version numbers

=head1 SYNOPSIS

wgd version [-b | -c] [<version>]

=head1 DESCRIPTION

Reports the current versions of the WebGUI.pm module, create.sql database
script, changelog, and upgrade file.  Non-matching versions will be noted
in red if possible.

=head1 OPTIONS

=over 8

=item B<--create>

Adds a new section to the changelog for the new version, updates the version
number in WebGUI.pm, and creates a new upgrade script.  The version number to
update to can be specified on the command line.  If not specified, defaults
to incrementing the patch level by one.

=item B<--bare>

Outputs the version number taken from WebGUI.pm only

=item B<E<lt>versionE<gt>>

version number to compare against or create

=back

=head1 AUTHOR

Graham Knop <graham@plainblack.com>

=head1 LICENSE

Copyright (c) Graham Knop.  All rights reserved.

This library is free software; you can redistribute it and/or modify it under
the same terms as Perl itself.

=cut


=head1 NAME

WGDev::Database - Database connectivity and DSN parsing for WGDev

=head1 SYNOPSIS

    my $dsn = $wgd->database->connect;
    my $username = $wgd->database->username;

=head1 DESCRIPTION

Has methods to access various parts of the DSN that can be used for other
programs such as command line mysql.  Also has methods to easily connect and
reuse a database connection.

=head1 METHODS

=head2 new ( $wgd )

Creates a new WGDev::Database object.

=head3 $wgd

An instantiated WGDev object.

=head1 AUTHOR

Graham Knop <graham@plainblack.com>

=head1 LICENSE

Copyright (c) Graham Knop.  All rights reserved.

This library is free software; you can redistribute it and/or modify it under
the same terms as Perl itself.

=cut


=head1 NAME

WGDev::Help - Generate help text for WGDev

=head1 SYNOPSIS

    use WGDev::Help;

    my $usage = WGDev::Help::package_usage( 'My::Class' );

=head1 DESCRIPTION

Reads help information from modules but filters to only pick relevant
sections when multiple POD documents exist in a single file.

=head1 SUBROUTINES

=head2 package_usage ( $package, $verbosity )

Returns usage information for a package, using L<Pod::Usage>.  Can be used on
packages that have been combined into a single file.

=head3 $package

Package to return usage documentation for

=head3 $verbosity

Verbosity level as documented in L<Pod::Usage>

=head1 AUTHOR

Graham Knop <graham@plainblack.com>

=head1 LICENSE

Copyright (c) Graham Knop.  All rights reserved.

This library is free software; you can redistribute it and/or modify it under
the same terms as Perl itself.

=cut

=head1 NAME

WGDev::Version - Extract version information from WebGUI

=head1 SYNOPSIS

    my $wgv = WGDev::Version->new('/data/WebGUI');
    print "You have WebGUI " . $wgv->module . "\n";

=head1 DESCRIPTION

Extracts version information from various places in WebGUI: the changelog, the
upgrade script, the WebGUI module, the database creation script, or a live
database.

=head1 METHODS

=head2 new ( $webgui_root )

Creates a new WGDev::Version object.  Needs a WebGUI directory to be specified.

=head3 $webgui_root

The root of the WebGUI directory to use for finding each file.

=head1 AUTHOR

Graham Knop <graham@plainblack.com>

=head1 LICENSE

Copyright (c) Graham Knop.  All rights reserved.

This library is free software; you can redistribute it and/or modify it under
the same terms as Perl itself.

=cut

