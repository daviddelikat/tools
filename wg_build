#!/usr/bin/env perl
use strict;
use warnings;

our $VERSION = '0.1.0';

use Getopt::Long ();
use Pod::Usage;

my $opt_verbose = 0;
Getopt::Long::Configure(qw(gnu_getopt));
Getopt::Long::GetOptions(
    'h|?|help'      => \(my $opt_help),
    'man'           => \(my $opt_man),
    'V|ver|version' => \(my $opt_ver),

    's|sql!'        => \(my $opt_sql),
    'u|uploads!'    => \(my $opt_uploads),
    'v|verbose'     => sub { $opt_verbose++ },
    'q|quiet'       => sub { $opt_verbose-- },
) || pod2usage(2);
if ($opt_help) {
    pod2usage(1);
}
elsif ($opt_man) {
    pod2usage(-verbose => 2);
}
elsif ($opt_ver) {
    print "wg_build - version $VERSION\n";
    exit;
}

$opt_sql        = defined $opt_sql      ? $opt_sql
                : defined $opt_uploads  ? !$opt_uploads
                                        : 1;
$opt_uploads    = defined $opt_uploads  ? $opt_uploads  : 0;

# load needed modules
unshift @INC, '/data/wre/lib';

require WRE::Config;
require Config::JSON;

# Autoflush
local $| = 1;

my $wre_config = WRE::Config->new;

my $config_file = (shift @ARGV) || $ENV{WEBGUI_CONFIG} || die <<'END_ERROR';
You must set the WEBGUI_CONFIG environment variable or provide a parameter to determine which site to reset
END_ERROR
print "Loading config... " if $opt_verbose >= 1;
my $config = Config::JSON->new($wre_config->getWebguiRoot('/etc/' . $config_file));
my ($dsn, $db_name, $db_host, $db_port, $db_user, $db_pass) = get_db_info($config);
print "Done.\n" if $opt_verbose >= 1;

if ($opt_sql) {
    require DBI;
    require version;
    print "Finding current version number... " if $opt_verbose >= 1;
    my $dbh = DBI->connect($dsn, $db_user, $db_pass);
    my $sth = $dbh->prepare('SELECT webguiVersion FROM webguiVersion');
    $sth->execute;
    my @versions =
        map { $_->[0] }
        sort { $a->[1] <=> $b->[1]}
        map { [$_, version->new($_)] }
        map {@$_} @{$sth->fetchall_arrayref([0])};
    $sth->finish;
    my $version = pop @versions;
    print "Done.\n" if $opt_verbose >= 1;

    print "Creating database dump... " if $opt_verbose >= 1;
    open my $fh, '>', $wre_config->getWebguiRoot('/docs/create.sql');
    close $fh;

    $sth = $dbh->table_info(undef, undef, '%');
    my @tables = map {@$_} @{$sth->fetchall_arrayref([2])};
    $sth->finish;

    for my $table (@tables) {
        my $skipData = $table =~ /^(?:userSession|userSessionScratch|webguiVersion|userLoginLog|assetHistory|cache)$/ ? ' --no-data' : '';
        system($wre_config->getRoot('/prereqs/bin/mysqldump') . " -u$db_user -p$db_pass -h$db_host -P$db_port$skipData --compact $db_name $table >> " . $wre_config->getWebguiRoot('/docs/create.sql'));
    }

    open $fh, '>>', $wre_config->getWebguiRoot('/docs/create.sql');
    print {$fh} "INSERT INTO webguiVersion (webguiVersion,versionType,dateApplied) VALUES ('$version','Initial Install',UNIX_TIMESTAMP());\n";
    close $fh;
    print "Done.\n" if $opt_verbose >= 1;
}

# Clear and recreate uploads
if ($opt_uploads) {
    require Path::Class::Dir;
    require File::Copy;
    print "Loading uploads from site... " if $opt_verbose >= 1;
    my $wg_uploads = Path::Class::Dir->new($wre_config->getWebguiRoot, 'www', 'uploads');
    my $site_uploads = Path::Class::Dir->new($config->get('uploadsPath'));
    unless (fork()) {
        require File::Spec;
        open STDOUT, '>', File::Spec->devnull unless $opt_verbose >= 2;
        $wg_uploads->recurse(callback => sub {
            my $wg_path = shift;
            for ($wg_path->is_dir ? $wg_path->dir_list : $wg_path->parent->dir_list) {
                return if $_ eq '.svn';
                return if $_ eq 'temp';
            }
            my $site_path = $wg_path->relative($wg_uploads)->absolute($site_uploads);
            if (! -e $site_path) {
                system 'svn', 'delete', $wg_path;
            }
        });
        $site_uploads->recurse(callback => sub {
            my $site_path = shift;
            return if $site_path->is_dir;
            for ($site_path->parent->dir_list) {
                return if $_ eq '.svn';
                return if $_ eq 'temp';
            }
            my $wg_path = $site_path->relative($site_uploads)->absolute($wg_uploads);
            $wg_path->parent->mkpath;
            File::Copy::copy($site_path->stringify, $wg_path->stringify);
        });
        system 'svn', 'add', '--force', $wg_uploads;
        exit;
    }
    wait;
    print "Done\n" if $opt_verbose >= 1;
}

sub get_db_info {
    my $config = shift;
    my $dsn     = $config->get('dsn');
    my $db_user = $config->get('dbuser');
    my $db_pass = $config->get('dbpass');
    my $db_name = (split(/[:;]/, $dsn))[2];
    my $db_host = 'localhost';
    my $db_port = '3306';
    while ($dsn =~ /([^=;:]+)=([^;:]+)/g) {
        if ($1 eq 'host' || $1 eq 'hostname') {
            $db_host = $2;
        }
        elsif ($1 eq 'db' || $1 eq 'database' || $1 eq 'dbname') {
            $db_name = $2;
        }
        elsif ($1 eq 'port') {
            $db_port = $2;
        }
    }
    return ($dsn, $db_name, $db_host, $db_port, $db_user, $db_pass);
}

__END__

=head1 NAME

wg_build - Rebuilds create.sql or uploads directory based on current site

=head1 SYNOPSIS

wg_build [options] [config ...]

Options:
    --help          brief help message
    --man           full documentation

=head1 OPTIONS

=over 8

=item B<--help>

Print a brief help message and exits.

=item B<--man>

Prints the manual page and exits.

=back

=head1 DESCRIPTION


=cut

